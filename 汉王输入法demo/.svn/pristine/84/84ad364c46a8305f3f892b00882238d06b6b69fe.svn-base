//
//  GZWrightKeyboard.m
//  HanvonKeyboard
//
//  Created by hanvon on 2017/11/4.
//  Copyright © 2017年 hanvon. All rights reserved.
//

#import "GZWrightKeyboard.h"
#import "GZWright.h"
//#import "UIStrokeShowerView.h"
#import "StrokeShowerView.h"


// 触摸类型
typedef enum {
    UITouchStart,
    UITouchMove,
    UITouchUp,
} UITouchTypes;

// 触摸操作类型
typedef enum {
    UITouchProcessUndefined,
    UITouchProcessStroke,
    UITouchProcessKey,
} UITouchProcessType;



@interface GZWrightKeyboard ()
{
@private
    NSInteger touchProcessType;
    BOOL pointInStrokeView;

    CGPoint lastStrokePoint;

    NSTimer *timer;
    NSTimer *deleteTimer;
    //    int timeout;
}
@property (nonatomic,retain) StrokeShowerView *strokeView; // 笔迹视图
@end



@implementation GZWrightKeyboard

- (instancetype)initWithFrame:(CGRect)frame {
    self = [super initWithFrame:frame];
    if (self) {
        //创建view
        [self createUI:frame];
        
//        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(notificationTellChangeBackgroundColor:) name:@"notificationTellChangeBackgroundColor" object:nil];

    }
    return self;
}


- (void)changeViewFrame:(CGRect)newFrame {
    self.frame = newFrame;
    if (newFrame.size.height == 150) {
        //横屏
        [self changeHengeFrame];
    }else {
        //竖屏
        [self changeShuFrame];
    }

/*
    CGFloat spaceX = 5.0;
    CGFloat spaceY = 7.0;
    CGFloat top = 3.0;
    CGFloat bottom = 3.0;

    CGFloat buttonH = (newFrame.size.height - top - bottom - spaceY*3)/4.0; //按钮的高度
    CGFloat buttonW = (newFrame.size.width - spaceX)/8.0; //功能按钮宽度

    //手写板
    CGFloat strokeW = (newFrame.size.width - spaceX - buttonW*2); //手写板宽
    CGFloat strokeH = newFrame.size.height - top - bottom; //手写板高
    CGFloat strokeX = buttonW;

    CGRect rect = CGRectMake(strokeX, top, strokeW, strokeH);
    _strokeView.frame = CGRectIntegral(rect);
    [_strokeView releaseWorkspace];
    [_strokeView initKeyboardWorkSpace]; //空间重新

    //创建左侧view
    CGFloat leftH = buttonH+spaceY;
    for (int i=0; i<4; i++) {
        //按钮
        GZFunctionButton *button = (GZFunctionButton*)[self viewWithTag:211+i];
        button.frame = CGRectMake(0, i*leftH, buttonW, leftH);

        //分割线
        if (i != 3) {
            UILabel *line = (UILabel*)[self viewWithTag:221+i];
            line.frame = CGRectMake(0, (i+1)*leftH, buttonW, 1);
        }
    }

    // 右侧view
    CGFloat rightX = buttonW + strokeW;
    for (int i=0; i<4; i++) {
        GZFunctionButton *button = (GZFunctionButton*)[self viewWithTag:231+i];
        button.frame = CGRectMake(rightX, top + i*(buttonH+spaceY), buttonW, buttonH);
    }
 */
}

- (void)changeBackgroudColor {
    GZUserDefaults *share = [GZUserDefaults shareUserDefaults];
    NSString * skinName = [share getGroupValueForKey:@"keyboardSkin"];
    GZKeyboardSkin *skin = [GZKeyboardSkin defaultKeyboardSkin];
    //背景图
    if (skin.backgroudImage_kb) {
        UIImageView *imageview = [[UIImageView alloc] initWithFrame:self.bounds];
        imageview.image = [UIImage imageNamed:skin.backgroudImage_kb];
        [self addSubview:imageview];
    }
    //背景色
    self.backgroundColor = skin.backgroungColor_kb;

    //左侧
    //NSArray *superLeftSubs = [NSArray arrayWithObjects:@"，",@"空格",@"中英",@"next", nil];
    for (int i=0; i<4; i++) {
        GZFunctionButton_wright_l *button = (GZFunctionButton_wright_l*)[self viewWithTag:211+i];
        [button setButtonStyleWithSkin:skinName];
    }

    //右侧
    //NSArray *superRightSubs = [NSArray arrayWithObjects:@"删除",@"符",@"123",@"回车", nil];
    for (int i=0; i<4; i++) {
        //按钮
        GZFunctionButton *button = (GZFunctionButton*)[self viewWithTag:231+i];
        [button setButtonStyleWithSkin:skinName];
    }

    //句号
    GZFunctionButton *button1 = (GZFunctionButton*)[self viewWithTag:241];
    if (button1) {
        [button1 setButtonStyleWithSkin:skinName];
    }

    //空格
    GZFunctionButton *button2 = (GZFunctionButton*)[self viewWithTag:300];
    [button2 setButtonStyleWithSkin:skinName];
}



- (void)createUI:(CGRect)newFrame {
    self.frame = newFrame;
    if (newFrame.size.height == 150) {
        //横屏
        [self createHengUI];
    }else {
        //竖屏
        [self createShuUI];
    }
}

#pragma mark -- private 手写横竖屏的布局不同
//竖屏
- (void)createShuUI {
    //键盘布局 水平间距5 垂直间距7
    //键盘布局 顶部间距3 底部间距3
    CGFloat spaceX = 5.0;
    CGFloat spaceY = 7.0;
    CGFloat top = 3.0;
    CGFloat bottom = 3.0;

    CGFloat buttonH = (self.frame.size.height - top - bottom - spaceY*3)/4.0; //按钮的高度
    CGFloat buttonW = (self.frame.size.width - 7*spaceX)/(4+2*1.5); //功能按钮宽度

    //创建手写板
    CGFloat strokeW = (self.frame.size.width - 3*spaceX - buttonW); //手写板宽
    CGFloat strokeH = self.frame.size.height - top - bottom - spaceY - buttonH; //手写板高
    CGFloat strokeX = spaceX;

    CGRect rect = CGRectMake(strokeX, top, strokeW, strokeH);
    _strokeView = [[StrokeShowerView alloc] initWithFrame:CGRectIntegral(rect)];
    _strokeView.backgroundColor = [UIColor whiteColor];//RGBA(210, 213, 219, 1.0);//
    _strokeView.layer.cornerRadius = 5;
    _strokeView.clipsToBounds = YES;
    [self addSubview:_strokeView];


    GZUserDefaults *share = [GZUserDefaults shareUserDefaults];
    NSString * skin = [share getGroupValueForKey:@"keyboardSkin"];

    //创建底部view
    //NSArray *superLeftSubs = [NSArray arrayWithObjects:@"符",@"123",@"中英",@"next", nil]; 211+i
    //NSArray *superLeftSubs = [NSArray arrayWithObjects:@"符",@"next",@"123",@"空格",@"中英",@"换行", nil];
    CGFloat buttonY = top + strokeH + spaceY;
    CGFloat konggeW = buttonW*1.5;

    for (int i=0; i<6; i++) {
        //按钮
        GZFunctionButton *button = [GZFunctionButton buttonWithType:UIButtonTypeCustom];
        [button setButtonStyleWithSkin:skin];
        [button addTarget:self action:@selector(didButtonTap:) forControlEvents:UIControlEventTouchUpInside];
        [self addSubview:button];

        //tag值
        if (i == 0) {
            button.tag = 211;
        }else if (i == 1) {
            button.tag = 214;
        }else if (i == 2) {
            button.tag = 212;
        }else if (i == 3) {
            button.tag = 300; //空格
        }else if (i == 4) {
            button.tag = 213;
        }else if (i == 5) {
            button.tag = 234; //回车
        }

        //坐标
        if (i < 3) {
            button.frame = CGRectMake(spaceX + i*(spaceX+buttonW), buttonY, buttonW, buttonH);
        }else if (i == 3) {
            //空格
            button.frame = CGRectMake(spaceX + 3*(spaceX+buttonW), buttonY, konggeW, buttonH);
            //button.backgroundColor = skin.backgroungColor_btn;
        }else if (i == 4) {
            //中英切换
            CGFloat changeX = spaceX*5 + buttonW*3 +konggeW; //中英切换 x坐标
            button.frame = CGRectMake(changeX, buttonY, buttonW, buttonH);
        }else {
            //回车
            CGFloat sureX = spaceX*6 + buttonW*4 + konggeW;
            button.frame = CGRectMake(sureX, buttonY, SCREEN_WIDTH-spaceX-sureX, buttonH);
        }

        //标题
        if (i == 0) {
            [button setTitle:@"符" forState:UIControlStateNormal];
            button.titleLabel.font = [UIFont systemFontOfSize:18];
        }else if (i == 1) {
            [button setImage:[UIImage imageNamed:@"keyboard_esrth"] forState:UIControlStateNormal];

        }else if (i == 2) {
            [button setTitle:@"123" forState:UIControlStateNormal];
            button.titleLabel.font = [UIFont systemFontOfSize:18];
        }else if (i == 3) {
            [button setTitle:@"空格" forState:UIControlStateNormal];
            button.titleLabel.font = [UIFont systemFontOfSize:18];
            //[button setTitleColor:skin.titleColor_btn forState:UIControlStateNormal];
        }else if (i == 4) {
            [button setImage:[UIImage imageNamed:@"keyboard_ch_en"] forState:UIControlStateNormal];
        }else {
            [button setTitle:@"换行" forState:UIControlStateNormal];
            button.titleLabel.font = [UIFont systemFontOfSize:18];
        }
    }


    // 右侧view
    CGFloat rightX = self.frame.size.width - spaceX - buttonW;
    //NSArray *superRightSubs = [NSArray arrayWithObjects:@"删除",@",",@"空格",@"回车", nil];
    NSArray *superRightSubs = [NSArray arrayWithObjects:@"删除",@",",@"。", nil];
    for (int i=0; i<3; i++) {
        //按钮
        GZFunctionButton *button = [GZFunctionButton buttonWithType:UIButtonTypeCustom];
        [button setButtonStyleWithSkin:skin];
        button.frame = CGRectMake(rightX, top + i*(buttonH+spaceY), buttonW, buttonH);
        [self addSubview:button];

        if (i == 2) {
            button.tag = 241;
        }else {
            button.tag = 231+i;
        }

        if (i == 0) {
            [button setImage:[UIImage imageNamed:@"keyboard_clear"] forState:UIControlStateNormal];
            [button addTarget:self action:@selector(didTouchDown) forControlEvents:UIControlEventTouchDown];
            [button addTarget:self action:@selector(didTouchUp) forControlEvents:UIControlEventTouchUpInside];
            [button addTarget:self action:@selector(didTouchUp) forControlEvents:UIControlEventTouchDragInside]; //移动手指出按钮
        }else {
            button.titleLabel.font = [UIFont systemFontOfSize:18];
            [button setTitle:superRightSubs[i] forState:UIControlStateNormal];
            [button addTarget:self action:@selector(didButtonTap:) forControlEvents:UIControlEventTouchUpInside];
        }
    }
}

- (void)changeShuFrame {
    //键盘布局 水平间距5 垂直间距7
    //键盘布局 顶部间距3 底部间距3
    CGFloat spaceX = 5.0;
    CGFloat spaceY = 7.0;
    CGFloat top = 3.0;
    CGFloat bottom = 3.0;

    CGFloat buttonH = (self.frame.size.height - top - bottom - spaceY*3)/4.0; //按钮的高度
    CGFloat buttonW = (self.frame.size.width - 7*spaceX)/(4+2*1.5); //功能按钮宽度

    //创建手写板
    CGFloat strokeW = (self.frame.size.width - 3*spaceX - buttonW); //手写板宽
    CGFloat strokeH = self.frame.size.height - top - bottom - spaceY - buttonH; //手写板高
    CGFloat strokeX = spaceX;

    CGRect rect = CGRectMake(strokeX, top, strokeW, strokeH);
    _strokeView.frame = CGRectIntegral(rect);


    //创建底部view
    //NSArray *superLeftSubs = [NSArray arrayWithObjects:@"符",@"next",@"123",@"空格",@"中英",@"换行", nil];
    CGFloat buttonY = top + strokeH + spaceY;
    CGFloat konggeW = buttonW*1.5;


//    GZFunctionButton *button1 = (GZFunctionButton*)[self viewWithTag:211]; //符号
//    GZFunctionButton *button2 = (GZFunctionButton*)[self viewWithTag:214]; //next
//    GZFunctionButton *button3 = (GZFunctionButton*)[self viewWithTag:212]; //123
//    GZFunctionButton *button4 = (GZFunctionButton*)[self viewWithTag:300]; //空格
//    GZFunctionButton *button5 = (GZFunctionButton*)[self viewWithTag:213]; //中英
//    GZFunctionButton *button6 = (GZFunctionButton*)[self viewWithTag:234]; //换行

    NSArray *num = @[@211,@214,@212,@300,@213,@234];
    for (int i=0; i<6; i++) {
        //按钮
        NSInteger tt = [num[i] integerValue];
        GZFunctionButton *button = (GZFunctionButton *)[self viewWithTag:tt];
        //坐标
        if (i < 3) {
            button.frame = CGRectMake(spaceX + i*(spaceX+buttonW), buttonY, buttonW, buttonH);
        }else if (i == 3) {
            //空格
            button.frame = CGRectMake(spaceX + 3*(spaceX+buttonW), buttonY, konggeW, buttonH);
            //button.backgroundColor = skin.backgroungColor_btn;
        }else if (i == 4) {
            //中英切换
            CGFloat changeX = spaceX*5 + buttonW*3 +konggeW; //中英切换 x坐标
            button.frame = CGRectMake(changeX, buttonY, buttonW, buttonH);
        }else {
            //回车
            CGFloat sureX = spaceX*6 + buttonW*4 + konggeW;
            button.frame = CGRectMake(sureX, buttonY, SCREEN_WIDTH-spaceX-sureX, buttonH);
        }
    }

    // 右侧view
    CGFloat rightX = self.frame.size.width - spaceX - buttonW;
    //NSArray *superRightSubs = [NSArray arrayWithObjects:@"删除",@",",@"。", nil];
    NSArray *num2 = @[@231,@232,@241];
    for (int i=0; i<3; i++) {
        NSInteger tt = [num2[i] integerValue];
        GZFunctionButton *button = (GZFunctionButton *)[self viewWithTag:tt];
        if (button) {
            button.frame = CGRectMake(rightX, top + i*(buttonH+spaceY), buttonW, buttonH);

        }else {
            //没有句号
            GZUserDefaults *share = [GZUserDefaults shareUserDefaults];
            NSString * skin = [share getGroupValueForKey:@"keyboardSkin"];
            NSArray *superRightSubs = [NSArray arrayWithObjects:@"删除",@",",@"。", nil];

            GZFunctionButton *button = [GZFunctionButton buttonWithType:UIButtonTypeCustom];
            [button setButtonStyleWithSkin:skin];
            button.frame = CGRectMake(rightX, top + i*(buttonH+spaceY), buttonW, buttonH);
            [self addSubview:button];

            if (i == 2) {
                button.tag = 241;
            }else {
                button.tag = 231+i;
            }

            if (i == 0) {
                [button setImage:[UIImage imageNamed:@"keyboard_clear"] forState:UIControlStateNormal];
                [button addTarget:self action:@selector(didTouchDown) forControlEvents:UIControlEventTouchDown];
                [button addTarget:self action:@selector(didTouchUp) forControlEvents:UIControlEventTouchUpInside];
                [button addTarget:self action:@selector(didTouchUp) forControlEvents:UIControlEventTouchDragInside]; //移动手指出按钮
            }else {
                button.titleLabel.font = [UIFont systemFontOfSize:18];
                [button setTitle:superRightSubs[i] forState:UIControlStateNormal];
                [button addTarget:self action:@selector(didButtonTap:) forControlEvents:UIControlEventTouchUpInside];
            }
        }
    }
}

//横屏
- (void)createHengUI {
    //键盘布局 水平间距5 垂直间距7
    //键盘布局 顶部间距3 底部间距3
    CGFloat spaceX = 5.0;
    CGFloat spaceY = 7.0;
    CGFloat top = 3.0;
    CGFloat bottom = 3.0;

    CGFloat buttonH = (self.frame.size.height - top - bottom - spaceY*3)/4.0; //按钮的高度
    CGFloat buttonW = (self.frame.size.width - 7*spaceX)/(4+2*1.5); //功能按钮宽度

    //创建手写板
    CGFloat strokeW = (self.frame.size.width - 4*spaceX - buttonW*2); //手写板宽
    CGFloat strokeH = self.frame.size.height - top - bottom; //手写板高
    CGFloat strokeX = 2*spaceX + buttonW;

    CGRect rect = CGRectMake(strokeX, top, strokeW, strokeH);
    _strokeView = [[StrokeShowerView alloc] initWithFrame:CGRectIntegral(rect)];
    _strokeView.backgroundColor = [UIColor whiteColor];//RGBA(210, 213, 219, 1.0);//
    _strokeView.layer.cornerRadius = 5;
    _strokeView.clipsToBounds = YES;
    [self addSubview:_strokeView];


    GZUserDefaults *share = [GZUserDefaults shareUserDefaults];
    NSString * skin = [share getGroupValueForKey:@"keyboardSkin"];

    //创建左侧view
    //NSArray *superLeftSubs = [NSArray arrayWithObjects:@"，",@"空格",@"中英",@"next", nil];
    NSArray *superLeftSubs = [NSArray arrayWithObjects:@"符",@"123",@"中英",@"next", nil];
    for (int i=0; i<4; i++) {
        //按钮
        GZFunctionButton *button = [GZFunctionButton buttonWithType:UIButtonTypeCustom];
        [button setButtonStyleWithSkin:skin];
        button.titleLabel.font = [UIFont systemFontOfSize:18];
        [button addTarget:self action:@selector(didButtonTap:) forControlEvents:UIControlEventTouchUpInside];
        button.frame = CGRectMake(spaceX, top + i*(buttonH+spaceY), buttonW, buttonH);
        button.tag = 211+i;
        [self addSubview:button];

        if (i == 3) {
            [button setImage:[UIImage imageNamed:@"keyboard_esrth"] forState:UIControlStateNormal];
        }else if (i == 2) {
            [button setImage:[UIImage imageNamed:@"keyboard_ch_en"] forState:UIControlStateNormal];
        }else {
            [button setTitle:superLeftSubs[i] forState:UIControlStateNormal];
        }
    }


    // 右侧view
    CGFloat rightX = self.frame.size.width - spaceX - buttonW;
    //NSArray *superRightSubs = [NSArray arrayWithObjects:@"删除",@"符",@"123",@"回车", nil];
    NSArray *superRightSubs = [NSArray arrayWithObjects:@"删除",@",",@"空格",@"回车", nil];
    for (int i=0; i<4; i++) {
        //按钮
        GZFunctionButton *button = [GZFunctionButton buttonWithType:UIButtonTypeCustom];
        [button setButtonStyleWithSkin:skin];
        button.frame = CGRectMake(rightX, top + i*(buttonH+spaceY), buttonW, buttonH);
        [self addSubview:button];

        if (i == 2) {
            //空格
            button.tag = 300;
        }else {
            button.tag = 231+i;
        }

        if (i == 0) {
            [button setImage:[UIImage imageNamed:@"keyboard_clear"] forState:UIControlStateNormal];
            [button addTarget:self action:@selector(didTouchDown) forControlEvents:UIControlEventTouchDown];
            [button addTarget:self action:@selector(didTouchUp) forControlEvents:UIControlEventTouchUpInside];
            [button addTarget:self action:@selector(didTouchUp) forControlEvents:UIControlEventTouchDragInside]; //移动手指出按钮
        }else {
            button.titleLabel.font = [UIFont systemFontOfSize:18];
            [button setTitle:superRightSubs[i] forState:UIControlStateNormal];
            [button addTarget:self action:@selector(didButtonTap:) forControlEvents:UIControlEventTouchUpInside];
        }
    }
}

- (void)changeHengeFrame {
    //键盘布局 水平间距5 垂直间距7
    //键盘布局 顶部间距3 底部间距3
    CGFloat spaceX = 5.0;
    CGFloat spaceY = 7.0;
    CGFloat top = 3.0;
    CGFloat bottom = 3.0;

    CGFloat buttonH = (self.frame.size.height - top - bottom - spaceY*3)/4.0; //按钮的高度
    CGFloat buttonW = (self.frame.size.width - 7*spaceX)/(4+2*1.5); //功能按钮宽度

    //创建手写板
    CGFloat strokeW = (self.frame.size.width - 4*spaceX - buttonW*2); //手写板宽
    CGFloat strokeH = self.frame.size.height - top - bottom; //手写板高
    CGFloat strokeX = 2*spaceX + buttonW;

    CGRect rect = CGRectMake(strokeX, top, strokeW, strokeH);
    _strokeView.frame = CGRectIntegral(rect);


    //创建左侧view
    //NSArray *superLeftSubs = [NSArray arrayWithObjects:@"符",@"123",@"中英",@"next", nil];
    for (int i=0; i<4; i++) {
        //按钮
        GZFunctionButton *button = (GZFunctionButton *)[self viewWithTag:211+i];
        button.frame = CGRectMake(spaceX, top + i*(buttonH+spaceY), buttonW, buttonH);
    }


    // 右侧view
    CGFloat rightX = self.frame.size.width - spaceX - buttonW;
    //NSArray *superRightSubs = [NSArray arrayWithObjects:@"删除",@",",@"空格",@"回车", nil];
    NSArray *num2 = @[@231,@232,@300,@234];
    for (int i=0; i<4; i++) {
        NSInteger tt = [num2[i] integerValue];
        GZFunctionButton *button = (GZFunctionButton *)[self viewWithTag:tt];
        button.frame = CGRectMake(rightX, top + i*(buttonH+spaceY), buttonW, buttonH);
    }

    //逗号多出
    GZFunctionButton *button = (GZFunctionButton *)[self viewWithTag:241];
    if (button) {
        [button removeFromSuperview];
        button = nil;
    }

}


#pragma mark -- button click action
- (void)didButtonTap:(UIButton*)tap {
    UIButton *button = (UIButton*)tap;
    NSInteger tagN = button.tag;
    int text = 0; //1符号，2数字，3中英，4next 5删除 6逗号 7回车 8句号 9空格
    //（211+i） 1符号 2数字 3中英切换 4next  （@"符",@"123",@"中英",@"next"）
    // (231+i) 5删除 6逗号  7回车  （@"删除",@",",@"空格",@"回车"）
    //（241）8句号
    //（300）9空格
    switch (tagN) {
        case 211:{
            NSLog(@"符号");
            text = 1;
            break;
        }
        case 212: {
            NSLog(@"数字");
            text = 2;
            break;
        }
        case 213: {
            NSLog(@"中英");
            text = 3;
            break;
        }
        case 214: {
            NSLog(@"next");
            text = 4;
            break;
        }
        case 231: {
            NSLog(@"删除");
            text = 5;
            break;
        }
        case 232: {
            NSLog(@"逗号");
            text = 6;
            break;
        }
        case 234: {
            NSLog(@"回车");
            text = 7;
            break;
        }
        case 241: {
            NSLog(@"句号");
            text = 8;
            break;
        }
        case 300: {
            NSLog(@"空格");
            text = 9;
            break;
        }
        default:
            break;
    }

    if (text != 0 && self.sendSelectedFunc) {
        self.sendSelectedFunc(text);
    }
}


//删除按钮---------------------------------
/*
 UIControlEventTouchDown即按钮按下时应触发的方法。
 实际使用过程中会出现延迟响应或间歇无响应，
 但是放开手指时会直接响应UIControlEventTouchDown、UIControlEventTouchUpInside两个方法
 touchesBegan不响应 不能用之获取按钮坐标
 */
- (void)didTouchDown {
    NSLog(@"didTouchDown");

    [self deleteActionStart]; //延时问题

    if (!deleteTimer) {
        deleteTimer = [NSTimer scheduledTimerWithTimeInterval:0.12 target:self selector:@selector(deleteActionStart) userInfo:nil repeats:YES];
    }
}
- (void)didTouchUp {
    NSLog(@"didTouchUp");
    [deleteTimer invalidate];
    deleteTimer = nil;
    [self deleteActionStop];
}

- (void)deleteActionStart {
    if (self.sendDeleteTap) {
        self.sendDeleteTap(YES);
    }
}
- (void)deleteActionStop {
    if (self.sendDeleteTap) {
        self.sendDeleteTap(NO);
    }
}



#pragma mark - Responding to Touch Events
- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
    [self dispatchTouches:touches withType:UITouchStart];
    [timer invalidate]; //停止计时
}
- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {
    [self dispatchTouches:touches withType:UITouchMove];
}
- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
    [self dispatchTouches:touches withType:UITouchUp];
}
- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event {
    [_strokeView clearStroke];
    if (self.sendWrightPoint) {
        self.sendWrightPoint(0, CGPointMake(0, 0), 0, 0);
    }
}

#pragma mark - Private
// 分发触摸事件
- (void)dispatchTouches:(NSSet *)touches withType:(UITouchTypes)type {
    UITouch* touch = [touches anyObject];
    // 手写视图
    [self touchStroke:touch withType:type];
}
// 手写处理
- (BOOL)touchStroke:(UITouch *)touch withType:(UITouchTypes)type {
    if (_strokeView == nil || (touchProcessType != UITouchProcessStroke && type != UITouchStart)) {
        return NO;
    }
    CGPoint point = [touch locationInView:_strokeView];

//    point.x -= _strokeView.frame.origin.x;
//    point.y -= _strokeView.frame.origin.y;
    switch (type) {
        case UITouchStart:

            if (CGRectContainsPoint(_strokeView.bounds, point)) {
                touchProcessType = UITouchProcessStroke;
                pointInStrokeView = YES;
                [_strokeView strokeStartAtPoint:point];
                if (self.sendWrightPoint) {
                    self.sendWrightPoint(1, point, 0, 0);
                }
            } else {
                return NO;
            }
            break;
        case UITouchMove:
            // 点在视图内

            if (CGRectContainsPoint(_strokeView.bounds, point)) {
                //NSLog(@"视图内");
                if (!pointInStrokeView) {
                    pointInStrokeView = YES;
                    lastStrokePoint = [self correctPoint:lastStrokePoint referenceTo:point withStrokeSize:_strokeView.frame.size];
                    [_strokeView strokeStartAtPoint:lastStrokePoint];

                    if (self.sendWrightPoint) {
                        self.sendWrightPoint(1, lastStrokePoint, 0, 0);
                    }
                }
                [_strokeView strokeMoveToPoint:point];
                if (self.sendWrightPoint) {
                    self.sendWrightPoint(1, point, 0, 0);
                }
            }
            // 点在视图外
            else if (pointInStrokeView) {
                //NSLog(@"视图外");
                pointInStrokeView = NO;
                lastStrokePoint = [self correctPoint:point referenceTo:lastStrokePoint withStrokeSize:_strokeView.frame.size];
                [_strokeView strokeEndAtPoint:lastStrokePoint];
                if (self.sendWrightPoint) {
                    self.sendWrightPoint(2, lastStrokePoint, -1, 0);
                }
            }
            break;
        default:
            touchProcessType = UITouchProcessUndefined;
            if (!pointInStrokeView) {
                break;
            }
            [_strokeView strokeEndAtPoint:point];
            NSLog(@"point .... is  %@",NSStringFromCGPoint(point));
            if (self.sendWrightPoint) {
                self.sendWrightPoint(2, point, -1, 0);
            }
            break;
    }

    lastStrokePoint = point;
    return YES;
}



#pragma mark -- private method
// 修正点坐标到手写区域内，获取连接errorPoint和referencePoint的线段上边缘坐标点
// (x-x1)/(x2-x1) = (y-y1)/(y2-y1)
- (CGPoint)correctPoint:(CGPoint)errorPoint referenceTo:(CGPoint)referencePoint withStrokeSize:(CGSize)strokeSize {
    CGFloat threshold = 1;
    NSLog(@"errorpoint x is %f, y is %f,  referencePoint x is %f, y is %f", errorPoint.x, errorPoint.y, referencePoint.x, referencePoint.y);

    // 垂直
    if (ABS(errorPoint.x - referencePoint.x) < threshold) {
        NSLog(@"垂直");
        if(ABS(referencePoint.y - strokeSize.height) > referencePoint.y) {
            return CGPointMake(referencePoint.x, 0);
        } else {
            return CGPointMake(referencePoint.x, strokeSize.height);
        }
    }
    //手写区宽度= 320  高度 ＝ 177
    //    int writeWidth = 320;
    //    int writeHeight = 177;
    int writeWidth = strokeSize.width;
    int writeHeight = strokeSize.height;

    CGFloat calY = 0;
    CGFloat calX = 0;
    if (errorPoint.x < 0) {
        calX = 0;
        calY = referencePoint.x * (referencePoint.y - errorPoint.y ) / (errorPoint.x - referencePoint.x) + referencePoint.y;
        if (calY < 0) {
            calX = referencePoint.y * (referencePoint.x - errorPoint.x ) / (errorPoint.y - referencePoint.y) + referencePoint.x;
            calY = 0;
        }else if (calY > writeHeight){
            calY = writeHeight;
            calX = (referencePoint.y - calY) * (referencePoint.x - errorPoint.x ) / (errorPoint.y - referencePoint.y) + referencePoint.x;

        }

    }else if(errorPoint.x > writeWidth) {
        calX = writeWidth;
        calY = (referencePoint.x - calX) * (referencePoint.y - errorPoint.y ) / (errorPoint.x - referencePoint.x) + referencePoint.y;
        if (calY < 0) {
            calX = referencePoint.y * (referencePoint.x - errorPoint.x ) / (errorPoint.y - referencePoint.y) + referencePoint.x;
            calY = 0;
        }else if (calY > writeHeight){
            calY = writeHeight;
            calX = (referencePoint.y - calY)  * (referencePoint.x - errorPoint.x ) / (errorPoint.y - referencePoint.y) + referencePoint.x;
            calY = writeHeight;
        }
    }else{
        if (errorPoint.y < 0) {
            calY = 0;
            calX = referencePoint.y * (referencePoint.x - errorPoint.x ) / (errorPoint.y - referencePoint.y) + referencePoint.x;
        }else{
            calY = writeHeight;
            calX = (referencePoint.y - calY) * (referencePoint.x - errorPoint.x ) / (errorPoint.y - referencePoint.y) + referencePoint.x;

            NSLog(@"&&&&&&&&&&&&&&&&&");
        }
    }
    NSLog(@"\n\n\n calX is %f, calY is %f", calX, calY);
    /*

     CGFloat correctX = 0;
     CGFloat correctY = 0;

     // 水平
     if (ABS(errorPoint.y - referencePoint.y) < threshold) {
     NSLog(@"水平");
     return CGPointMake(0, referencePoint.y);
     }


     if (errorPoint.y > referencePoint.y) {
     correctY = 177;
     }

     if (errorPoint.x > referencePoint.x) {
     correctX = 320;
     }

     if (errorPoint.x < 0) {
     NSLog(@"假定与左侧边缘相交");
     // 假定与左侧边缘相交
     correctY = errorPoint.y - (referencePoint.y - errorPoint.y) * errorPoint.x / (referencePoint.x - errorPoint.x);
     // 与上边缘相交
     if (correctY < 0) {
     NSLog(@"与上边缘相交");
     correctY = 0;
     correctX = errorPoint.x - (referencePoint.x - errorPoint.x) * errorPoint.y / (referencePoint.y - errorPoint.y);
     }
     } else {
     NSLog(@"else errorPoint.x < 0");
     correctX = errorPoint.x - (referencePoint.x - errorPoint.x) * errorPoint.y / (referencePoint.y - errorPoint.y);
     }
     */

    return CGPointMake(calX, calY);
}


#pragma mark -- 清除痕迹
- (void)removeTracesAfter {
    timer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(removeTraces) userInfo:nil repeats:NO];
}
- (void)removeTraces {
    [_strokeView clearStroke];
    NSLog(@"手写清除痕迹timer");
}



- (void)dealloc {
    NSLog(@"手写键盘 销毁");

//    [[NSNotificationCenter defaultCenter] removeObserver:self name:@"notificationTellChangeBackgroundColor" object:nil];

    if (timer) {
        [timer invalidate];
        timer = nil;
    }
    if (deleteTimer) {
        [deleteTimer invalidate];
        deleteTimer = nil;
    }


    for (int i=0; i<4; i++) {
        UIButton *but = (UIButton*)[self viewWithTag:211+i];
        if (but) {
            [but removeFromSuperview];
            but = nil;
        }
        UILabel *line = (UILabel*)[self viewWithTag:221+i];
        if (line) {
            [line removeFromSuperview];
            line = nil;
        }
        UIButton *button = (UIButton*)[self viewWithTag:231+i];
        if (button) {
            [button removeFromSuperview];
            button = nil;
        }
    }

    if (_strokeView) {
        [_strokeView removeFromSuperview];
        _strokeView = nil;
    }

    for (UIView *view in self.subviews) {
        [view removeFromSuperview];
    }
}



/*
#pragma mark -- abandont
#pragma mark -- UI
- (void)addWrightArea {
    //水平间距5 垂直间距7 顶部间距3 底部间距3
    if (!_strokeView) {
        _strokeView = [[UIStrokeShowerView alloc] initWithFrame:CGRectMake(5, 3, self.frame.size.width-50, self.frame.size.height)];
        _strokeView.backgroundColor = [UIColor whiteColor];
        _strokeView.layer.cornerRadius = 5;
        _strokeView.layer.shadowColor = [UIColor blackColor].CGColor;
        _strokeView.layer.shadowOpacity = 1.0;
        _strokeView.layer.shadowOffset = CGSizeMake(0, 3);
        _strokeView.layer.shadowRadius = 5;
        [self addSubview:_strokeView];
    }
}
- (void)addButton {
    _oneButton = [UIButton buttonWithType:UIButtonTypeSystem];
    [_oneButton setTitle:@"1" forState:UIControlStateNormal];
    _oneButton.layer.cornerRadius = 8;
    _oneButton.backgroundColor = [UIColor whiteColor];
    [_oneButton setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
    _oneButton.titleLabel.font = [UIFont systemFontOfSize:20];
    _oneButton.tag = 101;
    [_oneButton addTarget:self action:@selector(didButtonTap:) forControlEvents:UIControlEventTouchUpInside];
    _oneButton.translatesAutoresizingMaskIntoConstraints = NO;
    [self addSubview:_oneButton];

    _twoButton = [UIButton buttonWithType:UIButtonTypeSystem];
    [_twoButton setTitle:@"2" forState:UIControlStateNormal];
    _twoButton.layer.cornerRadius = 8;
    _twoButton.backgroundColor = [UIColor whiteColor];
    [_twoButton setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
    _twoButton.titleLabel.font = [UIFont systemFontOfSize:20];
    _twoButton.tag = 102;
    [_twoButton addTarget:self action:@selector(didButtonTap:) forControlEvents:UIControlEventTouchUpInside];
    _twoButton.translatesAutoresizingMaskIntoConstraints = NO;
    [self addSubview:_twoButton];

    _threeButton = [UIButton buttonWithType:UIButtonTypeSystem];
    [_threeButton setTitle:@"3" forState:UIControlStateNormal];
    _threeButton.layer.cornerRadius = 8;
    _threeButton.backgroundColor = [UIColor whiteColor];
    [_threeButton setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
    _threeButton.titleLabel.font = [UIFont systemFontOfSize:20];
    _threeButton.tag = 103;
    [_threeButton addTarget:self action:@selector(didButtonTap:) forControlEvents:UIControlEventTouchUpInside];
    _threeButton.translatesAutoresizingMaskIntoConstraints = NO;
    [self addSubview:_threeButton];
}
- (void)addLayout {
    NSDictionary *views = NSDictionaryOfVariableBindings(self,_strokeView,_oneButton,_twoButton,_threeButton);

    [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"H:|[_strokeView]-5-[_oneButton(==_twoButton)]-5-|" options:0 metrics:0 views:views]];
    [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"H:|[_strokeView]-5-[_twoButton(==_threeButton)]-5-|" options:0 metrics:0 views:views]];
    [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"H:|[_strokeView]-5-[_threeButton]-5-|" options:0 metrics:0 views:views]];
    [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"V:|-5-[_oneButton(==_twoButton)]-5-[_twoButton(==_threeButton)]-5-[_threeButton]-5-|" options:0 metrics:0 views:views]];
}
*/



@end
