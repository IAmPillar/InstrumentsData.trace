//
//  GZWright.m
//  HanvonKeyboard
//
//  Created by hanvon on 2017/11/4.
//  Copyright © 2017年 hanvon. All rights reserved.
//

#import "GZWright.h"
#import "HW_API.h"
#import "LibraryUtility.h"
#import "HW_RangeMask.h"



// 识别结果空间大小
#define kBufferSize 1024
#define kUnicharBufferSize  (kBufferSize >> 1)

// 笔迹点空间大小
#define kPointBufferExtra   4
#define kPointBufferSize    (MAX_POINT_NUM << 1)

#define kGestureDelete  0x8
#define kGestureTable   0x9
#define kGestureEnter   0xd
#define kGestureSpace   0x20
#define kGestureUndo    0x1a
#define kGestureCopy    0x1b
#define kGesturePaste   0x1c
#define kGestureCut     0x1d
#define kGestureSelect  0x1e
static NSInteger kGestureCount = 9;
static NSInteger kGestureCode[] = {
    kGestureDelete,
    kGestureTable,
    kGestureEnter,
    kGestureSpace,

    kGestureUndo,
    kGestureCopy,
    kGesturePaste,
    kGestureCut,
    kGestureSelect,
};

@interface GZWright()
{
@private
    unsigned int imHandle[128];
    long _imBuffer[kBufferSize >> 2];

    unichar* imBuffer;
    char* imRam;
    unsigned char * dicContent;
    short strokePoint[kPointBufferSize + kPointBufferExtra];

    int mode; //书写识别方式 1中英文单字符 2中文短句 3中文短句重叠 4自由写

    NSInteger strokePointOffset;

    BOOL cancelled;

    NSTimer *timer; //时间间隔
}
@property (nonatomic, retain) NSOperationQueue *operationQueue; //线程队列

@property (nonatomic, retain) NSString* dictionary; // 识别字典

@property (nonatomic, retain) NSMutableArray * mCandidates;
@end


@implementation GZWright

+ (id)defaultWright{
    NSLog(@"创建defaultWright");
    static GZWright *share = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        share = [[self alloc] init];
        [share initKeyboardWorkSpace];
    });

    return share;
}


// 初始化工作空间
- (BOOL)initKeyboardWorkSpace {

    imBuffer = (unichar*)_imBuffer;

    if (imRam == NULL) {
        imRam = (char*)allocMemory(ENG_REC_RAM_SIZE);

        memset(imRam, 0, ENG_REC_RAM_SIZE);
        memset(imHandle, 0, sizeof(imHandle));

        if (HWERR_SUCCESS != HWRC_SetWorkSpace(imHandle, imRam, ENG_REC_RAM_SIZE)) {
            return NO;
        }
    }
    
    // 确定核心参数
    NSNumber* languageType = 0;
    NSLanguageType language = [languageType intValue];

    NSString* path;

    switch (language) {
        case NSLanguageTypeCN:{
            path = [NSString stringWithFormat:@"%@/%@",[[NSBundle mainBundle] bundlePath], @"HW_REC_CN.bin"];
            //charset |= ALC_TC_TO_SC;
            break;
        }

        default:{
            if (_dictionary != nil) {
                path = _dictionary;
            } else {
                path = [NSString stringWithFormat:@"%@/%@",[[NSBundle mainBundle] bundlePath], @"HW_REC_CN.bin"];
            }
            break;
        }
    }

    // 加载字典
    self.dictionary = path;
    if (dicContent == NULL) {
        dicContent = (unsigned char*)loadFile([_dictionary UTF8String], NULL);
    }

    //字典分离
    HWRC_SetRecogDic(imHandle, dicContent,HW_RC_LANGUAGE_CN);

    // 设置参数
    if (mode == 1 || mode == 2 || mode == 3 || mode == 4) {
        HWRC_SetRecogMode(imHandle, mode);
    }

    HWRC_SetRecogRange(imHandle,0xffffffff -ALC_GESTURE);

    // 配置键盘核心，联想词使用
    if (language == NSLanguageTypeEN) {
        return YES;
    }

    return YES;
}

// 增加笔迹点
- (void)addPointX:(short)x Y:(short)y complation:(SuccesWrightBlock)data {

    [timer invalidate];
    NSLog(@"====关闭====");

    if (imRam == NULL) {
        [self initKeyboardWorkSpace];
    }

    if (strokePointOffset > kPointBufferSize) {
        return;
    }

    cancelled = NO;
    strokePoint[strokePointOffset++] = x;
    strokePoint[strokePointOffset++] = y;

    NSLog(@"x=%d,y=%d",x,y);
    if (x == -1 && y == 0) {
        if (!self.operationQueue) {
            self.operationQueue = [[NSOperationQueue alloc] init] ;
            self.operationQueue.maxConcurrentOperationCount = 1; //设置最大并发线程数
        }

        [self.operationQueue addOperationWithBlock:^{
            NSArray *arr = [self recognition];
            [[NSOperationQueue mainQueue] addOperationWithBlock:^{
                data(arr);
                return;
            }];
        }];

        //        dispatch_queue_t global_queue = dispatch_get_global_queue(0, 0);
        //        dispatch_async(global_queue, ^{
        //            NSArray *arr = [self recognition];
        //
        //            dispatch_sync(dispatch_get_main_queue(), ^{
        //                data(arr);
        //                return;
        //            });
        //        });
    }
}

//设置书写空间识别方式 1中英文单字符 2中文短句 3中文短句重叠 4自由写
- (void)setWrightMode:(int)wrihtMode {
    if (imRam == NULL) {
        [self initKeyboardWorkSpace];
    }
    if (wrihtMode != 0) {
        mode = wrihtMode;
        HWRC_SetRecogMode(imHandle, mode);
    }
}

//开启计时器 记录两次输入间隔
- (void)startTime {
    NSLog(@"开启计时器");
    timer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(removeTraces) userInfo:nil repeats:NO];
}
- (void)removeTraces {
    [[NSNotificationCenter defaultCenter] postNotificationName:@"notificationTellTimeOut" object:nil userInfo:@{@"isTimeOut":@"yes"}];
}

// 重置
- (void)keyboardReset {
    if(_mCandidates != nil ){
        [_mCandidates removeAllObjects];
        _mCandidates = nil;
    }

    strokePointOffset = 0;
    cancelled = YES;
}

// 释放工作空间
- (void)releaseWorkspace {

    [self.operationQueue cancelAllOperations];

    cancelled = YES;

    if(_mCandidates != nil ){
        [_mCandidates removeAllObjects];
        _mCandidates = nil;
    }

    if (imRam) {
        releaseMemory(imRam);
        imRam = NULL;
    }

    if (timer) {
        [timer invalidate];
        timer = nil;
    }
}

#pragma mark -- private
// 识别工作
- (NSArray*)recognition
{
    if (_mCandidates.count > 0) {
        [_mCandidates removeAllObjects];
    }
    if (!_mCandidates) {
        _mCandidates = [[NSMutableArray alloc] init];
    }

    if (cancelled) {
        return nil;
    }
    cancelled = NO;

    if (strokePointOffset > kPointBufferSize) {
        // [self updateCandidate:nil];
        return nil;
    }

    strokePoint[strokePointOffset] = strokePoint[strokePointOffset+1] = -1;

    int result =HWRC_Recognize(imHandle, strokePoint);

    if (result != HWERR_SUCCESS) {
        return nil;
    }

    result = HWRC_GetResult(imHandle, 10, (char*)imBuffer);

    if (result < 1) {
        //[configuration.hwinputView resetInputView];
        return nil;
    }

    // 判断手势
    for (int i = 0; i < kGestureCount; ++i) {
        if (imBuffer[0] == kGestureCode[i]) {
            return nil;
        }
    }

    int count = 0;
    unichar code;

    int start, end;
    for (start = 0; start < kUnicharBufferSize && count < result;) {
        for (end = start; end < kUnicharBufferSize && (code = imBuffer[end]) != 0; ++end) {
            if (((code > 0x20 && code < 0x30) || (code > 0x39 && code < 0x7f))) {
                imBuffer[end] += 0xfee0;
            }
        }

        if (end >= kUnicharBufferSize) {
            break;
        }
        [_mCandidates addObject:[NSString stringWithCharacters:imBuffer+start length:end-start]];

        ++count;
        start = end + 1;
    }

    return _mCandidates;
}

@end
