//
//  GZSquared.m
//  HanvonKeyboard
//
//  Created by hanvon on 2017/12/11.
//  Copyright © 2017年 hanvon. All rights reserved.
//

#import "GZSquared.h"
#import "GZChineseKeyboardCore.h"

/* 结果缓存大小 */
#define kBufferSize 1024
#define kUnicharBufferSize (kBufferSize>>1)
#define kUnicharComposingSize 100


@interface GZSquared() {
    unsigned short imBuffer[kUnicharBufferSize];
    unsigned short composingBuffer[kUnicharComposingSize];
    unsigned int start; //获取已选音节在转换串的开始位置
    unsigned int end; //获取已选音节在转换串的结束位置
}
@end



@implementation GZSquared

static GZSquared *share;
static dispatch_once_t onceToken;

+ (id)defaultSquared{
    dispatch_once(&onceToken, ^{
        share = [[self alloc] init];
    });
    return share;
}
- (id)init {
    self = [super init];
    if (self) {
        [self initKeyboardWorkSpace];
    }
    return self;
}

// 初始化工作空间
- (BOOL)initKeyboardWorkSpace {
    NSLog(@"九键盘 初始化工作空间");

    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    [chineseK changeDictionary:0];
    HWIM_HANDLE *imHandle = [chineseK getHandle];

    if (0 != HWKIM_SetInputMode(imHandle,HWIM_MODE_PINYIN)) {
        NSLog(@"SetInputMode");
    }
    if (0 != HWKIM_SetKeyboardMode(imHandle, HWIM_KEYBOARD_REDUCE)) {
        NSLog(@"SetKeyboardMode");
    }

    GZUserDefaults *share = [GZUserDefaults shareUserDefaults];
    NSNumber *fuzzy = [share getValueForKey:@"fuzzy"];
    if ([fuzzy isEqualToNumber:@1]) {
        if (0 != HWKIM_SetPinyinFuzzy(imHandle, 0xFFF)) {
            NSLog(@"SetPinyinFuzzy");
        }
    }else {
        if (0 != HWKIM_SetPinyinFuzzy(imHandle, 0)) {
            NSLog(@"SetPinyinFuzzy");
        }
    }

    //    NSNumber *recovery = [share getValueForKey:@"recovery"]; //纠错
    //    if ([recovery isEqualToNumber:@1]) {
    //        if (0 != HWKIM_SetCorrection(imHandle, 1)) {
    //            NSLog(@"SetPinyinFuzzy");
    //        }
    //    }else {
    //        if (0 != HWKIM_SetCorrection(imHandle, 0)) {
    //            NSLog(@"SetPinyinFuzzy");
    //        }
    //    }
    //
    return YES;
}



#pragma mark -- 输入输出操作
//直接输入
- (void)sendInput:(int)inputCode complation:(SuccesInput)data {

    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    HWIM_HANDLE *imHandle = [chineseK getHandle];

    //    if (inputCode == 0x8) {//HW_KEY_BackSpace_Code
    //        if(shiftLastIndex > 0) {
    //            --shiftLastIndex;
    //        }
    //    }

    NSOperationQueue *operationQueue = [[GZQueue shareQueue] getOperationQueue];
    [operationQueue addOperationWithBlock:^{
        unsigned short code = (unsigned short)inputCode;
        if (0 != HWKIM_AddChar(imHandle, code)) {
            NSLog(@"AddChar");
        }
        NSArray *arr = [self doShowIntermediateResult:-1];
        NSString *compontText = arr[0] ;
        NSArray *candiateArray = arr[1] ;
        NSArray *pinyinCandidates = [self doShowPinyinCandidates] ;
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            data(compontText,candiateArray,pinyinCandidates);
            //            compontText = nil;
            //            candiateArray = nil;
            //            arr = nil;
            //            pinyinCandidates = nil;
            return;
        }];
    }];
}

//点击候选按钮 有联想
- (void)sendSelectedIndex:(int)index andStr:(NSString*)str selectComplation:(SuccesSelect)selectdata predicComplation:(SuccesPredict)predicdata {

    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    HWIM_HANDLE *imHandle = [chineseK getHandle];

    if (0 != HWKIM_ChooseCandWord(imHandle, index)) {
        NSLog(@"选择");
    }

    int isFinish = HWKIM_IsFinish(imHandle); //0否 1是
    if (isFinish == 0) {
        //未结束输入 修改
        [self selectComplation:selectdata];
    }else {
        //结束输入 联想
        [self predicInput:str complation:predicdata];
    }
}

//选择候选 没有联想
- (void)selectIndex:(int)index complation:(SuccesSelect)selectdata {
    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    HWIM_HANDLE *imHandle = [chineseK getHandle];

    if (0 != HWKIM_ChooseCandWord(imHandle, index)) {
        NSLog(@"选择");
    }

    int isFinish = HWKIM_IsFinish(imHandle); //0否 1是
    if (isFinish == 0) {
        //未结束输入 修改
        [self selectComplation:selectdata];
    }else {
        //结束输入 联想
        selectdata(nil,nil,nil);
    }
}

//选择某一 拼音候选
- (void)sendSelectedPinyinIndex:(int)index andStr:(NSString*)str complation:(SuccesSelect)data {
    NSOperationQueue *operationQueue = [[GZQueue shareQueue] getOperationQueue];
    [operationQueue addOperationWithBlock:^{
        //HWKIM_ChooseCandWord(&imHandle, index);
        NSArray *arr = [self doShowIntermediateResult:index];
        NSString *compontText = arr[0] ;
        NSArray *candiateArray = arr[1] ;
        NSArray *pinyinCandidates = [self doShowPinyinCandidates] ;
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            data(compontText,candiateArray,pinyinCandidates);
            //            compontText = nil;
            //            candiateArray = nil;
            //            arr = nil;
            //            pinyinCandidates = nil;
            return;
        }];
    }];
}

//联想输入
- (void)predicInput:(NSString*)text complation:(SuccesPredict)data {
    NSOperationQueue *operationQueue = [[GZQueue shareQueue] getOperationQueue];
    [operationQueue addOperationWithBlock:^{
        NSArray *result = [self doPrediction:text] ;
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            if (result.count == 0) {
                data(nil);
                return ;
            }
            data(result);
            //            result = nil;
            return;
        }];
    }];
}

//选择候选index是否结束
- (BOOL)isSelectFinish {
    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    HWIM_HANDLE *imHandle = [chineseK getHandle];
    if (0 == HWKIM_IsFinish(imHandle)) {
        return NO;
    }else {
        return YES;
    }
}

//候选结束，获取之前的选择 比如“好ren”
- (NSString*)getResultStr {
    // 显示中间结果  拼音
    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    HWIM_HANDLE *imHandle = [chineseK getHandle];
    NSString *result = @"";
    int composingLength = HWKIM_GetInputTransResult(imHandle, composingBuffer);
    if (composingLength > 0) {
        for(int i = 0; i < composingLength ;i++){
            int temp = composingBuffer[i];
            NSString *str = [NSString stringWithFormat:@"%C",(unichar)temp];
            result = [result stringByAppendingString:str];
        }
    }
    return result;
}


//获取拼音候选
- (NSArray*)getCompontArr {
    return [self doShowPinyinCandidates] ;
}

//获取拼音高亮的数据
- (NSInteger)getSelectedCompont {
    return end;
}

//修改模糊音设置
- (void)changeFuzzy {
    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    HWIM_HANDLE *imHandle = [chineseK getHandle];

    GZUserDefaults *share = [GZUserDefaults shareUserDefaults];
    NSNumber *fuzzy = [share getValueForKey:@"fuzzy"];
    if ([fuzzy isEqualToNumber:@1]) {
        if (0 != HWKIM_SetPinyinFuzzy(imHandle, 0xFFF)) {
            NSLog(@"change~SetPinyinFuzzy");
        }
    }else {
        if (0 != HWKIM_SetPinyinFuzzy(imHandle, 0)) {
            NSLog(@"change~SetPinyinFuzzy");
        }
    }
}

//修改纠错设置
- (void)changeRecovery {
    //    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    //    HWIM_HANDLE *imHandle = [chineseK getHandle];
    //
    //    GZUserDefaults *share = [GZUserDefaults shareUserDefaults];
    //    NSNumber *recovery = [share getValueForKey:@"recovery"];
    //    if ([recovery isEqualToNumber:@1]) {
    //        if (0 != HWKIM_SetCorrection(imHandle, 1)) {
    //            NSLog(@"SetPinyinFuzzy");
    //        }
    //    }else {
    //        if (0 != HWKIM_SetCorrection(imHandle, 0)) {
    //            NSLog(@"SetPinyinFuzzy");
    //        }
    //    }
}

// 重置
- (void)keyboardReset {
    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    [chineseK cleanData];
}

//释放单例
- (void)releaseShare {
    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    [chineseK cleanData];

    GZQueue *queue = [GZQueue shareQueue];
    [queue cancel];

    onceToken = 0;
    share = nil;
}
//释放字典
- (void)releaseDictionary {
    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    [chineseK releaseDictionary];

    GZQueue *queue = [GZQueue shareQueue];
    [queue cancel];

    onceToken = 0;
    share = nil;
}
// 释放工作空间
- (void)releaseWorkspace {
    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    [chineseK releaseWorkspace];

    GZQueue *queue = [GZQueue shareQueue];
    [queue cancel];

    onceToken = 0;
    share = nil;
}


#pragma mark -- 核心识别操作
//选择候选
- (void)selectComplation:(SuccesSelect)selectdata {
    NSOperationQueue *operationQueue = [[GZQueue shareQueue] getOperationQueue];
    [operationQueue addOperationWithBlock:^{
        NSArray *arr = [self doShowIntermediateResult:-1] ;
        NSString *compontText = arr[0] ;
        NSArray *candiateArray = arr[1] ;
        NSArray *pinyinCandidates = [self doShowPinyinCandidates] ;
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            selectdata(compontText,candiateArray,pinyinCandidates);
            //            arr = nil;
            //            compontText = nil;
            //            candiateArray = nil;
            //            pinyinCandidates = nil;
            return;
        }];
    }];
}

// 显示结果 输入结果最多接收100个（展开更多候选最多100个）
- (NSArray*)doShowIntermediateResult:(NSInteger)phoneIndex {

    NSMutableArray *candidates = [NSMutableArray arrayWithCapacity:0];
    NSString *composingText = @"";
    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    HWIM_HANDLE *imHandle = [chineseK getHandle];

    NSInteger candidateIndex = HWKIM_GetWordCandidates(imHandle, (int)phoneIndex, imBuffer, kBufferSize);
    if (candidateIndex > 100) {
        candidateIndex = 100;
    }

    //获取已选择的拼音的下划线
    if (0 != HWKIM_GetSelSylPos(imHandle,&(start),&(end))) {
        NSLog(@"GetSelSylPos");
    }else {
        NSLog(@"start == %d,end == %d",start,end);
    }

    // 显示中间结果  拼音
    int composingLength = HWKIM_GetInputTransResult(imHandle, composingBuffer);
    if (composingLength > 0) {
        for(int i = 0; i < composingLength ;i++){
            int temp = composingBuffer[i];
            composingText = [composingText stringByAppendingString:[NSString stringWithFormat:@"%C",(unichar)temp]];
        }
    }

    // 显示候选
    if (candidateIndex <= 0) {
        if (composingText != nil) {
            NSUInteger length = [composingText length];
            unichar data[length];
            [composingText getCharacters:data];
            //            for (int i = 0; i < shiftLastIndex; ++i) {
            //                if (shiftStatus[i]) {
            //                    data[i] += kShiftDiff;
            //                }
            //            }
            composingText = [NSString stringWithCharacters:data length:length];

            [candidates addObject:@""];
        }

        NSArray *resultArr = [NSArray arrayWithObjects:composingText, candidates ,nil];

        //        composingText = nil;
        //        [candidates removeAllObjects];
        //        candidates = nil;
        return resultArr;
    }

    int count = 0;
    int end;
    for (int start = 0; start < kUnicharBufferSize && count < candidateIndex;) {
        for (end = start; end < kUnicharBufferSize && imBuffer[end] != 0; ++end);

        if (end >= kUnicharBufferSize) {
            break;
        }

        //        if (shiftLastIndex > 0) {
        //            for (shiftIndex = 0; shiftIndex < shiftLastIndex; ++shiftIndex) {
        //                if (shiftStatus[shiftIndex]) {
        //                    imBuffer[start + shiftIndex] += kShiftDiff;
        //                }
        //            }
        //        }
        NSString *tempStr = @"";
        for(int i = start; i < end ; i++){
            int temp = imBuffer[i];
            tempStr = [tempStr stringByAppendingString:[NSString stringWithFormat:@"%C",(unichar)temp]];
        }

        //NSString *tempStr = [NSString stringWithCharacters:(imBuffer+start) length:end-start];
        [candidates addObject:tempStr];
        ++count;
        start = end + 1;
    }


    NSArray *resultArr = [NSArray arrayWithObjects:composingText, candidates ,nil];

    //    composingText = nil;
    //    [candidates removeAllObjects];
    //    candidates = nil;
    return resultArr;
}

//获取拼音候选
- (NSArray *)doShowPinyinCandidates {

    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    HWIM_HANDLE *imHandle = [chineseK getHandle];

    NSInteger numbers = HWKIM_GetPhoneticGroup(imHandle, imBuffer);
    if (numbers <= 0) {
        return nil;
    }

    NSMutableArray *candidates = [NSMutableArray arrayWithCapacity:0];

    int count = 0;
    int start, end;
    for (start = 0; start < kUnicharBufferSize && count < numbers;) {
        for (end = start; end < kUnicharBufferSize && imBuffer[end] != 0; ++end);

        if (end >= kUnicharBufferSize) {
            break;
        }

        NSString *tempStr = @"";
        for(int i = start; i < end ; i++){
            int temp = imBuffer[i];
            tempStr = [tempStr stringByAppendingString:[NSString stringWithFormat:@"%C",(unichar)temp]];
        }

        //NSString *tempStr = [NSString stringWithCharacters:(imBuffer+start) length:end-start];
        [candidates addObject:tempStr];
        ++count;
        start = end + 1;
    }

    //    NSArray *resultArr = [candidates copy];
    //    [candidates removeAllObjects];
    //    candidates = nil;
    return candidates;
}

//联想 联想结果最多接收30个（候选框最多30个）
- (NSArray*)doPrediction:(NSString*)data {
    NSInteger length = [data length];
    unsigned short root[length + 1];
    NSRange range;
    int result;

    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    HWIM_HANDLE *imHandle = [chineseK getHandle];

    NSMutableArray *predicts = [[NSMutableArray alloc] init];
    BOOL hasPredics = NO; //是否有联想结果了

    for (int i = 0; i < length; ++i) {
        if (hasPredics) {
            break;
        }

        range.location = i;
        range.length = length - i;
        [data getCharacters:root range:range];

        root[length - i] = 0;
        result = HWKIM_GetPredictResult(imHandle, root, NULL, imBuffer, kBufferSize);
        if (result > 30) {
            result = 30;
        }

        if (result < 1) {
            continue;
        }else {
            hasPredics = YES;
        }

        int count = 0;
        int start, end;

        for (start = 0; start < kUnicharBufferSize && count < result;) {
            while (imBuffer[start] == 0) {
                start++;
            }
            for (end = start; end < kUnicharBufferSize && imBuffer[end] != 0; ++end);
            if (end >= kUnicharBufferSize) {
                break;
            }

            NSString *tempStr = @"";
            for(int i = start; i < end; i++){
                int temp = imBuffer[i];
                tempStr = [tempStr stringByAppendingString:[NSString stringWithFormat:@"%C",(unichar)temp]];
            }
            [predicts addObject:tempStr];
            ++count;
            start = end + 1;
        }
    }

    //    NSArray *resultArr = [predicts copy];
    //    [predicts removeAllObjects];
    //    predicts = nil;

    return predicts;
}


@end
