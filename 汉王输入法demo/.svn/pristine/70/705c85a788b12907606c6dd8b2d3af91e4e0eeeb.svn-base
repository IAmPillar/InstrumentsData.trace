//
//  GZWright.m
//  HanvonKeyboard
//
//  Created by hanvon on 2017/11/4.
//  Copyright © 2017年 hanvon. All rights reserved.
//

#import "GZWright.h"
#import "GZWrightKeyboardCore.h"
#import "GZChineseKeyboardCore.h"

//#define kGestureDelete  0x8
//#define kGestureTable   0x9
//#define kGestureEnter   0xd
//#define kGestureSpace   0x20
//#define kGestureUndo    0x1a
//#define kGestureCopy    0x1b
//#define kGesturePaste   0x1c
//#define kGestureCut     0x1d
//#define kGestureSelect  0x1e
//static NSInteger kGestureCount = 9;
//static NSInteger kGestureCode[] = {
//    kGestureDelete,
//    kGestureTable,
//    kGestureEnter,
//    kGestureSpace,
//
//    kGestureUndo,
//    kGestureCopy,
//    kGesturePaste,
//    kGestureCut,
//    kGestureSelect,
//};
// 识别结果空间大小
#define kBufferSize 1024
#define kUnicharBufferSize  (kBufferSize >> 1)

// 笔迹点空间大小
#define kPointBufferExtra   4
#define kPointBufferSize    (MAX_POINT_NUM << 1)

@interface GZWright()
{
    long imBufferSize[kBufferSize >> 2];
//    unichar* imBuffer;
    unsigned short imBuffer[kUnicharBufferSize];

    short strokePoint[kPointBufferSize + kPointBufferExtra];
    short mode; //书写识别方式 1中英文单字符 2中文短句 3中文短句重叠 4自由写

    short strokePointOffset;
    NSTimer *timer; //时间间隔

    BOOL isHavePredict; //是否有联想功能
//    NSMutableString *pointStr;
}
@end


@implementation GZWright

static GZWright *share;
static dispatch_once_t onceToken;

+ (id)defaultWright{
    dispatch_once(&onceToken, ^{
        share = [[self alloc] init];
    });
    return share;
}
- (id)init {
    self = [super init];
    if (self) {
        [self initKeyboardWorkSpace];
    }
    return self;
}

// 初始化工作空间
- (BOOL)initKeyboardWorkSpace {
    //imBuffer = (unichar*)imBufferSize;

    GZWrightKeyboardCore *wrightK = [GZWrightKeyboardCore shareWrightKeyboardCore];
    unsigned int *imHandle = [wrightK getHandle];

    if (mode == 1 || mode == 2 || mode == 3 || mode == 4) {
        if (0 != HWRC_SetRecogMode(imHandle, mode)) {
            NSLog(@"SetRecogMode");
        }
    }

    if (0 != HWRC_SetRecogRange(imHandle,0xffffffff-ALC_GESTURE)) {
        NSLog(@"SetRecogRange");
    }

    return YES;
}

// 增加笔迹点
- (void)addPointX:(short)x Y:(short)y complation:(SuccesWrightBlock)data {

    [[NSNotificationCenter defaultCenter] postNotificationName:@"notificationTellTimeOut" object:nil userInfo:@{@"isTimeOut":@"no"}];

    [timer invalidate];

    if (strokePointOffset > kPointBufferSize) {
        return;
    }

    strokePoint[strokePointOffset++] = x;
    strokePoint[strokePointOffset++] = y;

//    //测试用
//    if (!pointStr) {
//        pointStr = [[NSMutableString alloc] init];
//    }
//    [pointStr appendFormat:@"%@", [NSString stringWithFormat:@"%d,%d,",x,y]];
//    NSLog(@"%@",pointStr);

    if (x == -1 && y == 0) {
        NSArray *arr = [[self recognition] copy];
        data(arr);
        arr = nil;
//        NSOperationQueue *operationQueue = [[GZQueue shareQueue] getOperationQueue];
//        [operationQueue addOperationWithBlock:^{
//            NSLog(@"传入数据");
//            __block NSArray *arr = [[self recognition] copy];
//            [[NSOperationQueue mainQueue] addOperationWithBlock:^{
//                data(arr);
//                arr = nil;
//                return;
//            }];
//        }];
    }
}

//设置书写空间识别方式 1中英文单字符 2中文短句 3中文短句重叠 4自由写
- (void)setWrightMode:(short)wrihtMode {
    GZWrightKeyboardCore *wrightK = [GZWrightKeyboardCore shareWrightKeyboardCore];
    unsigned int *imHandle = [wrightK getHandle];

    if (wrihtMode != 0) {
        mode = wrihtMode;
        HWRC_SetRecogMode(imHandle, mode);
    }

    HWRC_SetRecogRange(imHandle,0xffffffff -ALC_GESTURE);
}

//开启计时器 记录两次输入间隔
- (void)startTime {
    NSLog(@"开启计时器");
    timer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(removeTraces) userInfo:nil repeats:NO];
}
- (void)removeTraces {
    [[NSNotificationCenter defaultCenter] postNotificationName:@"notificationTellTimeOut" object:nil userInfo:@{@"isTimeOut":@"yes"}];
}

//添加联想功能
- (void)addPredictFunction {
    if (isHavePredict) {
        return;
    }

    NSLog(@"手写联想 初始化工作空间");
    isHavePredict = YES;

    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    [chineseK changeDictionary:2];

    HWIM_HANDLE *imHandle = [chineseK getHandle];

    if (0 != HWKIM_SetInputMode(imHandle,HWIM_MODE_PINYIN)) {
        NSLog(@"SetInputMode");
    }
    if (0 != HWKIM_SetPinyinFuzzy(imHandle, 0)) {
        NSLog(@"SetPinyinFuzzy");
    }
    if (0 != HWKIM_SetKeyboardMode(imHandle, HWIM_KEYBOARD_NOTREDUCE)) { //全键盘
        NSLog(@"SetKeyboardMode");
    }
}
//文字联想
- (void)predicInput:(NSString*)text complation:(SuccesWrightPredict)data {
    NSOperationQueue *operationQueue = [[GZQueue shareQueue] getOperationQueue];
    [operationQueue addOperationWithBlock:^{
        __block NSArray *result = [[self doPrediction:text] copy];
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            if (result.count == 0) {
                data(nil);
                return ;
            }
            data(result);
            result = nil;
            return;
        }];
    }];
}

// 重置
- (void)keyboardReset {
    strokePointOffset = 0;
    if (isHavePredict) {
        GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
        [chineseK cleanData];
    }
}

//释放联想的工作空间
- (void)releasePredictWorkspace {
    if (isHavePredict) {
        GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
        [chineseK releaseWorkspace];
        isHavePredict = NO;
    }
}

// 释放工作空间
- (void)releaseWorkspace {
    if (timer) {
        [timer invalidate];
        timer = nil;
        NSLog(@"timer释放");
    }

    if (isHavePredict) {
        GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
        [chineseK cleanData];
        isHavePredict = NO;
    }
    
    onceToken = 0;
    share = nil;
}

//退出app
- (void)quitOutApp {
    GZWrightKeyboardCore *wrightK = [GZWrightKeyboardCore shareWrightKeyboardCore];
    [wrightK releaseWorkspace];

    if (isHavePredict) {
        GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
        [chineseK releaseWorkspace];
        isHavePredict = NO;
    }

    if (timer) {
        [timer invalidate];
        timer = nil;
        NSLog(@"timer释放");
    }
    //imBuffer = nil;
    strokePointOffset = 0;

    onceToken = 0;
    share = nil;
}

#pragma mark -- private
// 识别工作 输入结果最多接收100个（展开更多候选最多100个）
- (NSArray*)recognition
{
    if (strokePointOffset > kPointBufferSize) {
        NSLog(@"失败2");
        return nil;
    }

    GZWrightKeyboardCore *wrightK = [GZWrightKeyboardCore shareWrightKeyboardCore];
    unsigned int *imHandle = [wrightK getHandle];

    strokePoint[strokePointOffset] = -1;
    strokePoint[strokePointOffset+1] = -1;
    NSLog(@"strokePointOffset == %d",strokePointOffset);

    if (HWERR_SUCCESS != HWRC_Recognize(imHandle, strokePoint)) {
        NSLog(@"失败3");
        return nil;
    }

    int result = HWRC_GetResult(imHandle, 10, (char*)imBuffer); //设置最多10个候选
    if (result < 1) {
        [self keyboardReset];
        NSLog(@"失败4");
        return nil;
    }
    if (result > 100) {
        result = 100;
    }
    // 判断手势
//    for (int i = 0; i < kGestureCount; ++i) {
//        if (imBuffer[0] == kGestureCode[i]) {
//            NSLog(@"失败5");
//            return nil;
//        }
//    }

    NSMutableArray *mCandidates = [[NSMutableArray alloc] init];

    int count = 0;
    int start, end;
    for (start = 0; start < kUnicharBufferSize && count < result;) {
        for (end = start; end < kUnicharBufferSize && (imBuffer[end]) != 0; ++end) {
//            unichar code = imBuffer[end];
//            if (((code > 0x20 && code < 0x30) || (code > 0x39 && code < 0x7f))) {
//                imBuffer[end] += 0xfee0;
//            }
        }

        if (end >= kUnicharBufferSize) {
            break;
        }


        NSString *string = [NSString stringWithCharacters:imBuffer+start length:end-start];
        if (string.length == 0) {
            ++count;
            start = end + 1;
            continue;
        }
//        NSLog(@"%@",string);
        //转成半角
        NSMutableString *convertedString = [string mutableCopy];
        CFStringTransform((CFMutableStringRef)convertedString, NULL, kCFStringTransformFullwidthHalfwidth, false);
        //添加到数组
        string = [convertedString copy];
        [mCandidates addObject:string];

        ++count;
        start = end + 1;

        convertedString = nil;
    }

    
    NSArray *resultArr = [mCandidates copy];
    [mCandidates removeAllObjects];
    mCandidates = nil;
    return resultArr;
}

//联想 联想结果最多接收30个（候选框最多30个）
- (NSArray*)doPrediction:(NSString*)data {
    NSInteger length = [data length];
    unsigned short root[length + 1];
    NSRange range;
    int result;

    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    HWIM_HANDLE *imHandle = [chineseK getHandle];

    NSMutableArray *predicts = [[NSMutableArray alloc] init];
    BOOL hasPredics = NO; //是否有联想结果了

    for (int i = 0; i < length; ++i) {
        if (hasPredics) {
            break;
        }
        
        range.location = i;
        range.length = length - i;
        [data getCharacters:root range:range];

        root[length - i] = 0;
        result = HWKIM_GetPredictResult(imHandle, root, NULL, imBuffer, kBufferSize);
        if (result > 30) {
            result = 30;
        }

        if (result < 1) {
            continue;
        }else {
            hasPredics = YES;
        }

        int count = 0;
        int start, end;

        for (start = 0; start < kUnicharBufferSize && count < result;) {
            while (imBuffer[start] == 0) {
                start++;
            }
            for (end = start; end < kUnicharBufferSize && imBuffer[end] != 0; ++end);
            if (end >= kUnicharBufferSize) {
                break;
            }

            NSString *tempStr = @"";
            for(int i = start; i < end; i++){
                int temp = imBuffer[i];
                tempStr = [tempStr stringByAppendingString:[NSString stringWithFormat:@"%C",(unichar)temp]];
            }
            [predicts addObject:tempStr];
            ++count;
            start = end + 1;
        }

    }

    NSArray *resultArr = [predicts copy];
    [predicts removeAllObjects];
    predicts = nil;

    return resultArr;
}

@end
