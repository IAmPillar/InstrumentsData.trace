//
//  GZStroke.m
//  HanvonKeyboard
//
//  Created by hanvon on 2017/12/13.
//  Copyright © 2017年 hanvon. All rights reserved.
//

#import "GZStroke.h"
#import "GZChineseKeyboardCore.h"


/* 结果缓存大小 */
#define kBufferSize 1024
#define kUnicharBufferSize (kBufferSize>>1)
#define kUnicharComposingSize 100


@interface GZStroke() {
    unsigned short imBuffer[kUnicharBufferSize];
    unsigned short composingBuffer[kUnicharComposingSize];
}
@end


@implementation GZStroke

static GZStroke *share;
static dispatch_once_t onceToken;

+ (id)defaultStroke{
    dispatch_once(&onceToken, ^{
        share = [[self alloc] init];
    });
    return share;
}
- (id)init {
    self = [super init];
    if (self) {
        [self initKeyboardWorkSpace];
    }
    return self;
}

// 初始化工作空间
- (BOOL)initKeyboardWorkSpace {
    NSLog(@"笔画键盘 初始化工作空间");

    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    [chineseK changeDictionary:0];
    HWIM_HANDLE *imHandle = [chineseK getHandle];

    HWKIM_SetInputMode(imHandle,HWIM_MODE_BIHUA);
    HWKIM_SetPinyinFuzzy(imHandle, 0);
//    NSLog(@"~~  HWKIM_SetLanguageDict ret is  %d", set);
//    NSLog(@"~~  HWKIM_SetUserDict ret is  %d", ret);

    //全键盘类型
    HWKIM_SetKeyboardMode(imHandle, HWIM_KEYBOARD_NOTREDUCE); //全键盘

    return YES;
}


#pragma mark -- 输入输出操作
//直接输入
- (void)sendInput:(int)inputCode complation:(InputBlock)data {
    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    HWIM_HANDLE *imHandle = [chineseK getHandle];

//    if (inputCode == 0x8) {//HW_KEY_BackSpace_Code
//        if(shiftLastIndex > 0) {
//            --shiftLastIndex;
//        }
//    }

    NSOperationQueue *operationQueue = [[GZQueue shareQueue] getOperationQueue];
    [operationQueue addOperationWithBlock:^{
        unsigned short code = (unsigned short)inputCode;
        HWKIM_AddChar(imHandle, code);
        __block NSArray *arr = [self doShowIntermediateResult:-1];
        __block NSString *compontText = [arr[0] copy];
        __block NSArray *candiateArray = [arr[1] copy];
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            data(compontText,candiateArray);
            compontText = nil;
            candiateArray = nil;
            arr = nil;
            return;
        }];
    }];
}

//点击候选按钮
- (void)sendSelectedIndex:(int)index andStr:(NSString*)str selectComplation:(SelectBlock)selectdata predicComplation:(PredictBlock)predicdata {

    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    HWIM_HANDLE *imHandle = [chineseK getHandle];

    HWKIM_ChooseCandWord(imHandle, index);

    int isFinish = HWKIM_IsFinish(imHandle); //0否 1是
    if (isFinish == 0) {
        //未结束输入 修改
        [self selectComplation:selectdata];
    }else {
        //结束输入 联想
        [self predicInput:str complation:predicdata];
    }
}

//选择候选
- (void)selectIndex:(int)index complation:(SelectBlock)selectdata {
    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    HWIM_HANDLE *imHandle = [chineseK getHandle];

    HWKIM_ChooseCandWord(imHandle, index);

    int isFinish = HWKIM_IsFinish(imHandle); //0否 1是
    if (isFinish == 0) {
        //未结束输入 修改
        [self selectComplation:selectdata];
    }else {
        //结束输入 联想
        selectdata(nil,nil);
    }
}

//联想输入
- (void)predicInput:(NSString*)text complation:(PredictBlock)data {
    NSOperationQueue *operationQueue = [[GZQueue shareQueue] getOperationQueue];
    [operationQueue addOperationWithBlock:^{
        __block NSArray *result = [[self doPrediction:text] copy];
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            if (result.count == 0) {
                data(nil);
                return ;
            }
            data(result);
            result = nil;
            return;
        }];
    }];
}

//选择候选index是否结束
- (BOOL)isSelectFinish {
    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    HWIM_HANDLE *imHandle = [chineseK getHandle];
    if (0 == HWKIM_IsFinish(imHandle)) {
        return NO;
    }else {
        return YES;
    }
}

//候选结束，获取之前的选择 比如“好ren”
- (NSString*)getResultStr {
    // 显示中间结果  拼音
    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    HWIM_HANDLE *imHandle = [chineseK getHandle];
    NSString *result = @"";
    int composingLength = HWKIM_GetInputTransResult(imHandle, composingBuffer);
    if (composingLength > 0) {
        for(int i = 0; i < composingLength ;i++){
            int temp = composingBuffer[i];
            NSString *str = [NSString stringWithFormat:@"%C",(unichar)temp];
            result = [result stringByAppendingString:str];
        }
    }
    return result;
}

// 重置
- (void)keyboardReset {
    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    [chineseK cleanData];
}

// 释放工作空间
- (void)releaseWorkspace {
    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    [chineseK cleanData];
    onceToken = 0;
    share = nil;
}

//退出app
- (void)quitOutApp {
    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    [chineseK releaseWorkspace];
    onceToken = 0;
    share = nil;
}

#pragma mark -- 核心识别操作
//选择候选
- (void)selectComplation:(SelectBlock)selectdata {
    NSOperationQueue *operationQueue = [[GZQueue shareQueue] getOperationQueue];
    [operationQueue addOperationWithBlock:^{
        __block NSArray *arr = [[self doShowIntermediateResult:-1] copy];
        __block NSString *compontText = [arr[0] copy];
        __block NSArray *candiateArray = [arr[1] copy];
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            selectdata(compontText,candiateArray);
            arr = nil;
            compontText = nil;
            candiateArray = nil;
            return;
        }];
    }];
}

// 显示结果 输入结果最多接收100个（展开更多候选最多100个）
- (NSArray*)doShowIntermediateResult:(NSInteger)phoneIndex {

    NSMutableArray *candidates = [NSMutableArray arrayWithCapacity:0];
    NSString *composingText = @"";
    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    HWIM_HANDLE *imHandle = [chineseK getHandle];

    NSInteger candidateIndex = HWKIM_GetWordCandidates(imHandle, (int)phoneIndex, imBuffer, kBufferSize);
    if (candidateIndex > 100) {
        candidateIndex = 100;
    }

    // 显示中间结果  拼音
    int composingLength = HWKIM_GetInputTransResult(imHandle, composingBuffer);
    if (composingLength > 0) {
        for(int i = 0; i < composingLength ;i++){
            int temp = composingBuffer[i];
            composingText = [composingText stringByAppendingString:[NSString stringWithFormat:@"%C",(unichar)temp]];
        }
    }

    // 显示候选
    if (candidateIndex <= 0) {
        if (composingText != nil) {
            NSUInteger length = [composingText length];
            unichar data[length];
            [composingText getCharacters:data];
//            for (int i = 0; i < shiftLastIndex; ++i) {
//                if (shiftStatus[i]) {
//                    data[i] += kShiftDiff;
//                }
//            }
            composingText = [NSString stringWithCharacters:data length:length];

            [candidates addObject:@""];
        }

        NSArray *resultArr = [NSArray arrayWithObjects:composingText, [candidates copy],nil];

        composingText = nil;
        [candidates removeAllObjects];
        candidates = nil;
        return resultArr;
    }

    int count = 0;
    int start, end;
    for (start = 0; start < kUnicharBufferSize && count < candidateIndex;) {
        for (end = start; end < kUnicharBufferSize && imBuffer[end] != 0; ++end);

        if (end >= kUnicharBufferSize) {
            break;
        }

        NSString *tempStr = @"";
        for(int i = start; i < end ; i++){
            int temp = imBuffer[i];
            tempStr = [tempStr stringByAppendingString:[NSString stringWithFormat:@"%C",(unichar)temp]];
        }

        //NSString *tempStr = [NSString stringWithCharacters:(imBuffer+start) length:end-start];
        [candidates addObject:tempStr];
        ++count;
        start = end + 1;
    }


    NSArray *resultArr = [NSArray arrayWithObjects:composingText, [candidates copy],nil];

    composingText = nil;
    [candidates removeAllObjects];
    candidates = nil;
    return resultArr;
}

//联想 联想结果最多接收30个（候选框最多30个）
- (NSArray*)doPrediction:(NSString*)data {
    NSInteger length = [data length];
    unsigned short root[length + 1];
    NSRange range;
    int result;
    
    GZChineseKeyboardCore *chineseK = [GZChineseKeyboardCore shareChineseKeyboardCore];
    HWIM_HANDLE *imHandle = [chineseK getHandle];

    NSMutableArray *predicts = [[NSMutableArray alloc] init];
    BOOL hasPredics = NO; //是否有联想结果了

    for (int i = 0; i < length; ++i) {
        if (hasPredics) {
            break;
        }
        
        range.location = i;
        range.length = length - i;
        [data getCharacters:root range:range];

        root[length - i] = 0;
        result = HWKIM_GetPredictResult(imHandle, root, NULL, imBuffer, kBufferSize);
        if (result > 30) {
            result = 30;
        }

        if (result < 1) {
            continue;
        }else {
            hasPredics = YES;
        }

        int count = 0;
        int start, end;

        for (start = 0; start < kUnicharBufferSize && count < result;) {
            while (imBuffer[start] == 0) {
                start++;
            }
            for (end = start; end < kUnicharBufferSize && imBuffer[end] != 0; ++end);
            if (end >= kUnicharBufferSize) {
                break;
            }

            NSString *tempStr = @"";
            for(int i = start; i < end; i++){
                int temp = imBuffer[i];
                tempStr = [tempStr stringByAppendingString:[NSString stringWithFormat:@"%C",(unichar)temp]];
            }
            [predicts addObject:tempStr];
            ++count;
            start = end + 1;
        }
    }

    NSArray *resultArr = [predicts copy];
    [predicts removeAllObjects];
    predicts = nil;

    return resultArr;
}


@end
