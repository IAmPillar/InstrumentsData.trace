//
//  StrokeShowerView.m
//  HanvonNotePad
//
//  Created by gao guoling on 11-10-20.
//  Copyright (c) 2011年 Hanwang Technology Co. All rights reserved.
//

#import "StrokeShowerView.h"
#import "HWColorPen.h"
#import "LibraryUtility.h"

#include <sys/types.h>
#include <sys/sysctl.h>
#include <mach/machine.h>

#define STROKE_WIDTH 5.0


@interface StrokeShowerView ()
{

    int bit; //32位 64位
    int bit_pixel; //32位 64位 对应的像素数
    CGFloat SelfWidth;
    CGFloat SelfHeight;
    CGFloat MEMORY;

    BOOL penColorTemp;
    unsigned char *imRam;
    color userColor;

    float penWidth;
    float penColorRed;
    float penColorGreen;
    float penColorBlue;
    float penColorAlpha;
    float penStyle;//1铅笔 2钢笔 3毛笔
}
@end

@implementation StrokeShowerView

//add by myself
- (instancetype)initWithFrame:(CGRect)frame {
    self = [super initWithFrame:frame];
    if (self) {

        if (!penColorRed && !penColorGreen && !penColorBlue && !penColorAlpha && !penStyle) {
            GZUserDefaults *share = [GZUserDefaults shareUserDefaults];

            penWidth = [[share getGroupValueForKey:@"penWidth"] intValue]; //笔画粗细
            penColorBlue = [[share getGroupValueForKey:@"penColorBlue"] floatValue];
            penColorGreen = [[share getGroupValueForKey:@"penColorGreen"] floatValue];
            penColorRed = [[share getGroupValueForKey:@"penColorRed"] floatValue];
            penColorAlpha = [[share getGroupValueForKey:@"penColorAlpha"] floatValue];
            if (penWidth < 1 || penWidth > 10 || !penWidth) {
                penWidth = 1;
            }
            if (penColorRed < 0 || penColorRed > 255 || !penColorRed) {
                penColorRed = 0;
            }
            if (penColorGreen < 0 || penColorGreen > 255 || !penColorGreen) {
                penColorGreen = 0;
            }
            if (penColorBlue < 0 || penColorBlue > 255 || !penColorBlue) {
                penColorBlue = 0;
            }
            if (penColorAlpha < 0 || penColorAlpha > 1 || !penColorAlpha) {
                penColorAlpha = 1;
            }
            penStyle = [[share getGroupValueForKey:@"penStyle"] intValue]; //1铅笔 2钢笔 3毛笔
        }

        BOOL is64Bit = [self is64bit];
        if (is64Bit) {
            bit = 64;
            bit_pixel = 8;
            NSLog(@"64+++++++++");
        }else {
            bit = 32;
            bit_pixel = 4;
            NSLog(@"32+++++++++");
        }

        [self initKeyboardWorkSpace];
    }
    return self;
}

// 初始化
- (void)initKeyboardWorkSpace
{
    SelfWidth = self.frame.size.width;//[[GZPublicMethod sharedPublicMethod] getPXWithPt:self.frame.size.width];//
    SelfHeight = self.frame.size.height;//[[GZPublicMethod sharedPublicMethod] getPXWithPt:self.frame.size.height];//
    MEMORY = SelfWidth * SelfHeight * bit_pixel;

    imRam = (unsigned char*)allocMemory(MEMORY);
//    imRam = (unsigned char *)malloc((MEMORY));
    memset(imRam, -1, MEMORY);

    HWPEN_initializeEx(SelfWidth, SelfHeight, (DWORD*)imRam, 0, 1);
    
    HWPEN_SetPen(1, penStyle, DARKBLUE, penWidth, 0);

    userColor.b = penColorBlue;
    userColor.r = penColorRed;
    userColor.g = penColorGreen;
    HWPEN_SetUserColor(userColor);

    penColorTemp = YES;
}


- (void)drawRect:(CGRect)rect
{
    if (!penColorTemp || !imRam) {
        [self initKeyboardWorkSpace];
    }

    CGColorSpaceRef crRef = CGColorSpaceCreateDeviceRGB();
    CGDataProviderRef provider = CGDataProviderCreateWithData(nil, imRam, (MEMORY), nil);
    if (crRef == NULL) {
        CGDataProviderRelease(provider);
        return;
    }

    CGImageRef imageRef = NULL;

    if (provider != NULL) {
        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Little| kCGImageAlphaLast;
        CGColorRenderingIntent renderingIntent = kCGRenderingIntentDefault;

        imageRef = CGImageCreate(SelfWidth, SelfHeight, 8, bit, SelfWidth * bit_pixel, crRef, bitmapInfo, provider, NULL, NO, renderingIntent);
        CGDataProviderRelease(provider);
    }
    
    CGColorSpaceRelease(crRef);
    
    if (imageRef != NULL) {
        CGContextRef context = UIGraphicsGetCurrentContext();
        
        if (context != NULL) {
            UIImage *img = [UIImage imageWithCGImage:imageRef];
            CGContextSaveGState(context);
            
            CGRect touchRect = CGRectMake(0, 0, img.size.width ,img.size.height );

            CGContextDrawImage(context, touchRect, imageRef);
            CGContextRestoreGState(context);
        }
       
        CGImageRelease(imageRef);
        UIGraphicsEndImageContext();
        imageRef = NULL;
    }
}


#pragma mark -- 手势操作
// 点击
- (void)strokeStartAtPoint:(CGPoint)point
{
    //CGRect rect = {0, 0, SelfWidth, SelfHeight};
    //[self drawRect:rect];
    CGFloat x = point.x;//[[GZPublicMethod sharedPublicMethod] getPXWithPt:point.x];//
    CGFloat y = point.y;//[[GZPublicMethod sharedPublicMethod] getPXWithPt:point.y];//
    NSLog(@"%f,%f",x, y);

    TRect re = {0, 0, SelfWidth, SelfHeight};

    HWPEN_DrawLine(x, y, &re, 0, 255, 0);
    
    [self setNeedsDisplay];
}
// 移动
- (void)strokeMoveToPoint:(CGPoint)point
{
    CGFloat x = point.x;//[[GZPublicMethod sharedPublicMethod] getPXWithPt:point.x];//
    CGFloat y = point.y;//[[GZPublicMethod sharedPublicMethod] getPXWithPt:point.y];//
    NSLog(@"%f,%f",x, y);

    TRect re = {0, 0, SelfWidth, SelfHeight};

    HWPEN_DrawLine(x, y, &re, 0, 255, 0);

    [self setNeedsDisplay];
}
// 抬起
- (void)strokeEndAtPoint:(CGPoint)point
{
//    CGFloat x = point.x;//[[GZPublicMethod sharedPublicMethod] getPXWithPt:point.x];//
//    CGFloat y = point.y;//[[GZPublicMethod sharedPublicMethod] getPXWithPt:point.y];//
//    NSLog(@"%f,%f",x, y);

    TRect re = {0, 0, SelfWidth, SelfHeight};

    HWPEN_DrawLine(-1, -1, &re, 0, 255, 0);
//    HWPEN_FadeRect(rect, 60);

    [self setNeedsDisplay];
}


// 清空笔迹
- (void)clearStroke
{
    //memset(imRam, 0x00, MEMORY);
    NSLog(@"~~ clearStroke");
    if (imRam != nil) {
        NSLog(@"~~ 释放  pencolor");
        releaseMemory(imRam);
        imRam = NULL;
    }
    
    penColorTemp = NO;
    [self setNeedsDisplay];
}

- (void)releaseWorkspace {
    if (imRam != nil) {
        NSLog(@"~~ 释放  pencolor");
        releaseMemory(imRam);
        imRam = NULL;
    }
}

//判断设备是否是64位
- (BOOL)is64bit {
    size_t size;
    cpu_type_t type;

    size = sizeof(type);
    sysctlbyname("hw.cputype", &type, &size, NULL, 0);

    if (type == CPU_TYPE_ARM64) {
        // ARM 64-bit CPU
        return YES;
    } else if (type == CPU_TYPE_ARM) {
        // ARM 32-bit CPU
    } else {
        // Something else.
    }
    return NO;
}



- (void)dealloc {
    NSLog(@"手写板 销毁");
}
@end
