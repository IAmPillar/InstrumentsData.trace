//
//  GZWrightKeyboard.m
//  HanvonKeyboard
//
//  Created by hanvon on 2017/11/4.
//  Copyright © 2017年 hanvon. All rights reserved.
//

#import "GZWrightKeyboard.h"
#import "GZWright.h"
//#import "UIStrokeShowerView.h"
#import "StrokeShowerView.h"


// 触摸类型
typedef enum {
    UITouchStart,
    UITouchMove,
    UITouchUp,
} UITouchTypes;

// 触摸操作类型
typedef enum {
    UITouchProcessUndefined,
    UITouchProcessStroke,
    UITouchProcessKey,
} UITouchProcessType;



@interface GZWrightKeyboard ()
{
    NSInteger touchProcessType;
    BOOL pointInStrokeView;

    CGPoint lastStrokePoint;

    NSTimer *timer; //笔画
    NSTimer *deleteTimer; //长按删除
    NSTimer *delay; //延时执行 长安删除操作

    BOOL hiddenStroke; //目前是否隐藏手写板

    UIView *superView; //底层的view
}
@property (nonatomic,retain) UIView *strokePlaceholderView; // 笔迹视图 占用
@property (nonatomic,retain) StrokeShowerView *strokeView; // 笔迹视图
@end



@implementation GZWrightKeyboard

- (instancetype)initWithFrame:(CGRect)frame withWrightMode:(int)mode andSuperView:(UIView*)superview{
    self = [super initWithFrame:frame];
    if (self) {
        //创建view
        hiddenStroke = YES;
        superView = superview;
        [self createUI:frame andWrightMode:mode];
    }
    return self;
}

- (void)changeBackgroudColor {
    //GZUserDefaults *share = [GZUserDefaults shareUserDefaults];
    //NSString * skinName = [share getGroupValueForKey:@"keyboardSkin"];
    //    GZKeyboardSkin *skin = [GZKeyboardSkin defaultKeyboardSkin];
    //    //背景图
    //    if (skin.backgroudImage_kb) {
    //        UIImageView *imageview = [[UIImageView alloc] initWithFrame:self.bounds];
    //        imageview.image = [UIImage imageNamed:skin.backgroudImage_kb];
    //        [self addSubview:imageview];
    //    }
    //背景色
    self.backgroundColor = Color_background_kb;

    //左侧
    //NSArray *superLeftSubs = [NSArray arrayWithObjects:@"，",@"空格",@"中英",@"next", nil];
    for (int i=0; i<4; i++) {
        GZFunctionButton_wright_l *button = (GZFunctionButton_wright_l*)[self viewWithTag:211+i];
        //[button setButtonStyleWithSkin:skinName];
        [button setBackgroundImage:[UIImage imageNamed:@"key_hightlight"] forState:UIControlStateHighlighted];
        [button setBackgroundColor:[UIColor clearColor]];
        [button setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
        button.layer.cornerRadius = 5;

    }

    //右侧
    //NSArray *superRightSubs = [NSArray arrayWithObjects:@"删除",@"#+=",@"123",@"回车", nil];
    for (int i=0; i<4; i++) {
        //按钮
        GZFunctionButton *button = (GZFunctionButton*)[self viewWithTag:231+i];
        //[button setButtonStyleWithSkin:skinName];
        [button setBackgroundImage:[UIImage imageNamed:@"key_hightlight"] forState:UIControlStateHighlighted];
        [button setBackgroundColor:[UIColor colorWithHexString:float_Color_button_function alpha:1]];
        [button setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
        button.layer.cornerRadius = 5;

    }

    //句号
    GZFunctionButton *button1 = (GZFunctionButton*)[self viewWithTag:241];
    if (button1) {
        //[button1 setButtonStyleWithSkin:skinName];
        [button1 setBackgroundImage:[UIImage imageNamed:@"key_hightlight"] forState:UIControlStateHighlighted];
        [button1 setBackgroundColor:[UIColor colorWithHexString:float_Color_button_function alpha:1]];
        [button1 setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
        button1.layer.cornerRadius = 5;

    }

    //空格
    GZFunctionButton *button2 = (GZFunctionButton*)[self viewWithTag:300];
    //[button2 setButtonStyleWithSkin:skinName];
    [button2 setBackgroundImage:[UIImage imageNamed:@"key_hightlight"] forState:UIControlStateHighlighted];
    [button2 setBackgroundColor:[UIColor colorWithHexString:float_Color_button_function alpha:1]];
    [button2 setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
    button2.layer.cornerRadius = 5;

}

- (void)changeViewFrame:(CGRect)newFrame withWrightMode:(int)mode{
    self.frame = newFrame;
    if (newFrame.size.height == 150 || newFrame.size.height == 200) {
        //横屏
        [self changeHengeFrameWithWrightMode:mode];
    }else {
        //竖屏
        [self changeShuFrameWithWrightMode:mode];
    }
}

//手动停止计时器
- (void)stopTimer {
    if (delay) {
        [delay invalidate];
        delay = nil;
    }
    if (deleteTimer) {
        [deleteTimer invalidate];
        deleteTimer = nil;
    }
    //    if (timer) {
    //        [timer invalidate];
    //        timer = nil;
    //    }
}

//是否将手写板置顶
- (void)bringStorkeViewToFront:(BOOL)toFront {
    if (toFront) {
        _strokeView.hidden = NO;
    }else {
        _strokeView.hidden = YES;
    }
}

//插入小地球视图，没有点击事件
- (void)insertGlobleView:(BOOL)insert byRect:(CGRect)rect {
    UIButton *imageB = (UIButton*)[self viewWithTag:886];
    if (!imageB) {
        imageB = [[UIButton alloc] init];
        imageB.frame = rect;
        imageB.tag = 886;
        [self insertSubview:imageB belowSubview:_strokeView];

        //GZKeyboardSkin *skin = [GZKeyboardSkin defaultKeyboardSkin];
        [imageB setBackgroundColor:[UIColor colorWithHexString:float_Color_button_function alpha:1]];
        [imageB setImage:[UIImage imageNamed:@"keyboard_esrth"] forState:UIControlStateNormal];
        imageB.layer.cornerRadius = 5;
    }else {
        imageB.frame = rect;
    }
    if (insert) {
        imageB.hidden = NO;
        hiddenStroke = NO;
    }else {
        imageB.hidden = YES;
        hiddenStroke = YES;
    }
}

//获取手写板视图
- (UIView*)getStokeView {
    return _strokeView;
}

//横竖切换
- (void)changeShuFrameWithWrightMode:(int)mode {
    //键盘布局 水平间距5 垂直间距7
    //键盘布局 顶部间距3 底部间距3
    CGFloat spaceX = 5.0;
    CGFloat spaceY = 7.0;
    CGFloat top = 3.0;
    CGFloat bottom = 3.0;

    CGFloat buttonH = (self.frame.size.height - top - bottom - spaceY*3)/4.0; //按钮的高度
    CGFloat buttonW = (self.frame.size.width - 7*spaceX)/(4+2*1.5); //功能按钮宽度

    //创建手写板
    CGFloat strokeW = (self.frame.size.width - 3*spaceX - buttonW); //手写板宽
    CGFloat strokeH = self.frame.size.height - top - bottom - spaceY - buttonH; //手写板高
    CGFloat strokeX = spaceX;
    //手写板placeholder
    CGRect rect = CGRectMake(strokeX, top, strokeW, strokeH);
    _strokePlaceholderView.frame = CGRectIntegral(rect);
    [self changeWrightMarkLabel:mode andHeight:strokeH];
    //手写板
    CGRect kbRect = CGRectMake(0, 0, self.frame.size.width, self.frame.size.height);
    _strokeView.frame = kbRect;
    //[_strokeView changeWrightMode:mode];
    [_strokeView changeFrame:kbRect];
    _strokeView.hidden = YES;

    //创建底部view
    //NSArray *superLeftSubs = [NSArray arrayWithObjects:@"#+=",@"next",@"123",@"空格",@"中英",@"换行", nil];
    CGFloat buttonY = top + strokeH + spaceY;
    CGFloat konggeW = buttonW*1.5;

    NSArray *num = @[@211,@214,@212,@300,@213,@234];
    for (int i=0; i<6; i++) {
        //按钮
        NSInteger tt = [num[i] integerValue];
        GZFunctionButton *button = (GZFunctionButton *)[self viewWithTag:tt];
        //坐标
        if (i < 3) {
            button.frame = CGRectMake(spaceX + i*(spaceX+buttonW), buttonY, buttonW, buttonH);
        }else if (i == 3) {
            //空格
            button.frame = CGRectMake(spaceX + 3*(spaceX+buttonW), buttonY, konggeW, buttonH);
            //button.backgroundColor = skin.backgroungColor_btn;
        }else if (i == 4) {
            //中英切换
            CGFloat changeX = spaceX*5 + buttonW*3 +konggeW; //中英切换 x坐标
            button.frame = CGRectMake(changeX, buttonY, buttonW, buttonH);
        }else {
            //回车
            CGFloat sureX = spaceX*6 + buttonW*4 + konggeW;
            button.frame = CGRectMake(sureX, buttonY, SCREEN_WIDTH-spaceX-sureX, buttonH);
        }
    }

    // 右侧view
    CGFloat rightX = self.frame.size.width - spaceX - buttonW;
    //NSArray *superRightSubs = [NSArray arrayWithObjects:@"删除",@",",@"。", nil];
    NSArray *num2 = @[@231,@232,@241];
    for (int i=0; i<3; i++) {
        NSInteger tt = [num2[i] integerValue];
        GZFunctionButton *button = (GZFunctionButton *)[self viewWithTag:tt];
        if (button) {
            button.frame = CGRectMake(rightX, top + i*(buttonH+spaceY), buttonW, buttonH);

        }else {
            //没有句号
            //GZUserDefaults *share = [GZUserDefaults shareUserDefaults];
            //NSString * skin = [share getGroupValueForKey:@"keyboardSkin"];
            NSArray *superRightSubs = [NSArray arrayWithObjects:@"删除",@",",@"。", nil];

            GZFunctionButton *button = [GZFunctionButton buttonWithType:UIButtonTypeCustom];
            //[button setButtonStyleWithSkin:skin];
            [button setBackgroundImage:[UIImage imageNamed:@"key_hightlight"] forState:UIControlStateHighlighted];
            [button setBackgroundColor:[UIColor colorWithHexString:float_Color_button_function alpha:1]];
            [button setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
            button.layer.cornerRadius = 5;

            button.frame = CGRectMake(rightX, top + i*(buttonH+spaceY), buttonW, buttonH);
            [self addSubview:button];

            if (i == 2) {
                button.tag = 241;
                [self insertSubview:button belowSubview:_strokeView];
            }else {
                button.tag = 231+i;
            }

            if (i == 0) {
                [button setImage:[UIImage imageNamed:@"keyboard_clear"] forState:UIControlStateNormal];
                [button addTarget:self action:@selector(didTouchDown) forControlEvents:UIControlEventTouchDown];
                [button addTarget:self action:@selector(didTouchUp) forControlEvents:UIControlEventTouchUpInside];
                [button addTarget:self action:@selector(didTouchUp) forControlEvents:UIControlEventTouchUpOutside]; //移动手指出按钮
            }else {
                button.titleLabel.font = [UIFont systemFontOfSize:18];
                [button setTitle:superRightSubs[i] forState:UIControlStateNormal];
                [button addTarget:self action:@selector(didButtonTap:) forControlEvents:UIControlEventTouchUpInside];
            }
        }
    }
}

- (void)changeHengeFrameWithWrightMode:(int)mode {
    //键盘布局 水平间距5 垂直间距7
    //键盘布局 顶部间距3 底部间距3
    CGFloat spaceX = 5.0;
    CGFloat spaceY = 7.0;
    CGFloat top = 3.0;
    CGFloat bottom = 3.0;

    CGFloat buttonH = (self.frame.size.height - top - bottom - spaceY*3)/4.0; //按钮的高度
    CGFloat buttonW = (self.frame.size.width - 7*spaceX)/(4+2*1.5); //功能按钮宽度

    //创建手写板
    CGFloat strokeW = (self.frame.size.width - 4*spaceX - buttonW*2); //手写板宽
    CGFloat strokeH = self.frame.size.height - top - bottom; //手写板高
    CGFloat strokeX = 2*spaceX + buttonW;

    CGRect rect = CGRectMake(strokeX, top, strokeW, strokeH);
    _strokePlaceholderView.frame = CGRectIntegral(rect);
    [self changeWrightMarkLabel:mode andHeight:strokeH];
    //手写板
    CGRect kbRect = CGRectMake(0, 0, self.frame.size.width, self.frame.size.height);
    _strokeView.frame = kbRect;
    //[_strokeView changeWrightMode:mode];
    [_strokeView changeFrame:kbRect];
    _strokeView.hidden = YES;

    //创建左侧view
    //NSArray *superLeftSubs = [NSArray arrayWithObjects:@"#+=",@"123",@"中英",@"next", nil];
    for (int i=0; i<4; i++) {
        //按钮
        GZFunctionButton *button = (GZFunctionButton *)[self viewWithTag:211+i];
        button.frame = CGRectMake(spaceX, top + i*(buttonH+spaceY), buttonW, buttonH);
    }


    // 右侧view
    CGFloat rightX = self.frame.size.width - spaceX - buttonW;
    //NSArray *superRightSubs = [NSArray arrayWithObjects:@"删除",@",",@"空格",@"回车", nil];
    NSArray *num2 = @[@231,@232,@300,@234];
    for (int i=0; i<4; i++) {
        NSInteger tt = [num2[i] integerValue];
        GZFunctionButton *button = (GZFunctionButton *)[self viewWithTag:tt];
        button.frame = CGRectMake(rightX, top + i*(buttonH+spaceY), buttonW, buttonH);
    }

    //逗号多出
    GZFunctionButton *button = (GZFunctionButton *)[self viewWithTag:241];
    if (button) {
        [button removeFromSuperview];
        button = nil;
    }

}

#pragma mark -- UI
- (void)createUI:(CGRect)newFrame andWrightMode:(int)mode{
    self.frame = newFrame;
    if (newFrame.size.height == 150 || newFrame.size.height == 200) {
        //横屏
        [self createHengUIWithWrightMode:mode];
    }else {
        //竖屏
        [self createShuUIWithWrightMode:mode];
    }
}

//竖屏
- (void)createShuUIWithWrightMode:(int)mode {
    //键盘布局 水平间距5 垂直间距7
    //键盘布局 顶部间距3 底部间距3
    CGFloat spaceX = 5.0;
    CGFloat spaceY = 7.0;
    CGFloat top = 3.0;
    CGFloat bottom = 3.0;

    CGFloat buttonH = (self.frame.size.height - top - bottom - spaceY*3)/4.0; //按钮的高度
    CGFloat buttonW = (self.frame.size.width - 7*spaceX)/(4+2*1.5); //功能按钮宽度

    //创建手写板
    CGFloat strokeW = (self.frame.size.width - 3*spaceX - buttonW); //手写板宽
    CGFloat strokeH = self.frame.size.height - top - bottom - spaceY - buttonH; //手写板高
    CGFloat strokeX = spaceX;
    //手写板的placeholder
    CGRect rect = CGRectMake(strokeX, top, strokeW, strokeH);
    _strokePlaceholderView = [[UIView alloc] initWithFrame:CGRectIntegral(rect)];
    _strokePlaceholderView.backgroundColor = [UIColor whiteColor];
    _strokePlaceholderView.layer.cornerRadius = 5;
    _strokePlaceholderView.clipsToBounds = YES;
    [self addSubview:_strokePlaceholderView];

    [self changeWrightMarkLabel:mode andHeight:strokeH];


    //GZUserDefaults *share = [GZUserDefaults shareUserDefaults];
    //NSString * skin = [share getGroupValueForKey:@"keyboardSkin"];

    //创建底部view
    //NSArray *superLeftSubs = [NSArray arrayWithObjects:@"#+=",@"123",@"中英",@"next", nil]; 211+i
    //NSArray *superLeftSubs = [NSArray arrayWithObjects:@"#+=",@"next",@"123",@"空格",@"中英",@"换行", nil];
    CGFloat buttonY = top + strokeH + spaceY;
    CGFloat konggeW = buttonW*1.5;

    for (int i=0; i<6; i++) {

        //排除next小地球按钮
        if (i == 1) {
            continue;
        }

        //按钮
        GZFunctionButton *button = [GZFunctionButton buttonWithType:UIButtonTypeCustom];
        //[button setButtonStyleWithSkin:skin];
        [button setBackgroundImage:[UIImage imageNamed:@"key_hightlight"] forState:UIControlStateHighlighted];
        [button setBackgroundColor:[UIColor colorWithHexString:float_Color_button_function alpha:1]];
        [button setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
        button.layer.cornerRadius = 5;

        [button addTarget:self action:@selector(didButtonTap:) forControlEvents:UIControlEventTouchUpInside];
        [self addSubview:button];

        //tag值
        if (i == 0) {
            button.tag = 211;
        }else if (i == 1) {
            button.tag = 214;
        }else if (i == 2) {
            button.tag = 212;
        }else if (i == 3) {
            button.tag = 300; //空格
        }else if (i == 4) {
            button.tag = 213;
        }else if (i == 5) {
            button.tag = 234; //回车
        }

        //坐标
        if (i < 3) {
            button.frame = CGRectMake(spaceX + i*(spaceX+buttonW), buttonY, buttonW, buttonH);
        }else if (i == 3) {
            //空格
            button.frame = CGRectMake(spaceX + 3*(spaceX+buttonW), buttonY, konggeW, buttonH);
            //button.backgroundColor = skin.backgroungColor_btn;
        }else if (i == 4) {
            //中英切换
            CGFloat changeX = spaceX*5 + buttonW*3 +konggeW; //中英切换 x坐标
            button.frame = CGRectMake(changeX, buttonY, buttonW, buttonH);
        }else {
            //回车
            CGFloat sureX = spaceX*6 + buttonW*4 + konggeW;
            button.frame = CGRectMake(sureX, buttonY, SCREEN_WIDTH-spaceX-sureX, buttonH);
        }

        //标题
        if (i == 0) {
            [button setTitle:@"#+=" forState:UIControlStateNormal];
            button.titleLabel.font = [UIFont systemFontOfSize:18];
        }else if (i == 1) {
            [button setImage:[UIImage imageNamed:@"keyboard_esrth"] forState:UIControlStateNormal];

        }else if (i == 2) {
            [button setTitle:@"123" forState:UIControlStateNormal];
            button.titleLabel.font = [UIFont systemFontOfSize:18];
        }else if (i == 3) {
            [button setImage:[UIImage imageNamed:@"keyboard_space_w"] forState:UIControlStateNormal];
            CGSize imageSize = button.imageView.bounds.size;
            button.imageEdgeInsets = UIEdgeInsetsMake(imageSize.height/2.5,0, -imageSize.height/2.5, 0);
        }else if (i == 4) {
            [button setImage:[UIImage imageNamed:@"keyboard_ch_en"] forState:UIControlStateNormal];
        }else {
            [button setImage:[UIImage imageNamed:@"keyboard_enter"] forState:UIControlStateNormal];
        }
    }


    // 右侧view
    CGFloat rightX = self.frame.size.width - spaceX - buttonW;
    //NSArray *superRightSubs = [NSArray arrayWithObjects:@"删除",@",",@"空格",@"回车", nil];
    NSArray *superRightSubs = [NSArray arrayWithObjects:@"删除",@",",@"。", nil];
    for (int i=0; i<3; i++) {
        //按钮
        GZFunctionButton *button = [GZFunctionButton buttonWithType:UIButtonTypeCustom];
        //[button setButtonStyleWithSkin:skin];
        [button setBackgroundImage:[UIImage imageNamed:@"key_hightlight"] forState:UIControlStateHighlighted];
        [button setBackgroundColor:[UIColor colorWithHexString:float_Color_button_function alpha:1]];
        [button setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
        button.layer.cornerRadius = 5;

        button.frame = CGRectMake(rightX, top + i*(buttonH+spaceY), buttonW, buttonH);
        [self addSubview:button];

        if (i == 2) {
            button.tag = 241;
        }else {
            button.tag = 231+i;
        }

        if (i == 0) {
            [button setImage:[UIImage imageNamed:@"keyboard_clear"] forState:UIControlStateNormal];
            [button addTarget:self action:@selector(didTouchDown) forControlEvents:UIControlEventTouchDown];
            [button addTarget:self action:@selector(didTouchUp) forControlEvents:UIControlEventTouchUpInside];
            [button addTarget:self action:@selector(didTouchUp) forControlEvents:UIControlEventTouchUpOutside]; //移动手指出按钮
        }else {
            button.titleLabel.font = [UIFont systemFontOfSize:18];
            [button setTitle:superRightSubs[i] forState:UIControlStateNormal];
            [button addTarget:self action:@selector(didButtonTap:) forControlEvents:UIControlEventTouchUpInside];
        }
    }

    //手写板
    CGSize kbSize = CGSizeMake(self.frame.size.width, self.frame.size.height);
    _strokeView = [[StrokeShowerView alloc] initWithFrame:CGRectMake(0, 0, kbSize.width, kbSize.height) andWrightMode:mode];
    _strokeView.backgroundColor = [UIColor clearColor];
    [self addSubview:_strokeView];
    _strokeView.hidden = YES;
    [superView bringSubviewToFront:_strokeView];
}

//横屏
- (void)createHengUIWithWrightMode:(int)mode {
    //键盘布局 水平间距5 垂直间距7
    //键盘布局 顶部间距3 底部间距3
    CGFloat spaceX = 5.0;
    CGFloat spaceY = 7.0;
    CGFloat top = 3.0;
    CGFloat bottom = 3.0;

    CGFloat buttonH = (self.frame.size.height - top - bottom - spaceY*3)/4.0; //按钮的高度
    CGFloat buttonW = (self.frame.size.width - 7*spaceX)/(4+2*1.5); //功能按钮宽度

    //创建手写板
    CGFloat strokeW = (self.frame.size.width - 4*spaceX - buttonW*2); //手写板宽
    CGFloat strokeH = self.frame.size.height - top - bottom; //手写板高
    CGFloat strokeX = 2*spaceX + buttonW;
    //手写板的placeholder
    CGRect rect = CGRectMake(strokeX, top, strokeW, strokeH);
    _strokePlaceholderView = [[UIView alloc] initWithFrame:CGRectIntegral(rect)];
    _strokePlaceholderView.backgroundColor = [UIColor whiteColor];//Color_background_kb;//
    _strokePlaceholderView.layer.cornerRadius = 5;
    _strokePlaceholderView.clipsToBounds = YES;
    [self addSubview:_strokePlaceholderView];

    [self changeWrightMarkLabel:mode andHeight:strokeH];


    //GZUserDefaults *share = [GZUserDefaults shareUserDefaults];
    //NSString * skin = [share getGroupValueForKey:@"keyboardSkin"];

    //创建左侧view
    //NSArray *superLeftSubs = [NSArray arrayWithObjects:@"，",@"空格",@"中英",@"next", nil];
    NSArray *superLeftSubs = [NSArray arrayWithObjects:@"#+=",@"123",@"中英",@"next", nil];
    for (int i=0; i<4; i++) {

        //排除next小地球按钮
        if (i == 3) {
            continue;
        }

        //按钮
        GZFunctionButton *button = [GZFunctionButton buttonWithType:UIButtonTypeCustom];
        //[button setButtonStyleWithSkin:skin];
        [button setBackgroundImage:[UIImage imageNamed:@"key_hightlight"] forState:UIControlStateHighlighted];
        [button setBackgroundColor:[UIColor colorWithHexString:float_Color_button_function alpha:1]];
        [button setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
        button.layer.cornerRadius = 5;

        button.titleLabel.font = [UIFont systemFontOfSize:18];
        [button addTarget:self action:@selector(didButtonTap:) forControlEvents:UIControlEventTouchUpInside];
        button.frame = CGRectMake(spaceX, top + i*(buttonH+spaceY), buttonW, buttonH);
        button.tag = 211+i;
        [self addSubview:button];

        if (i == 3) {
            [button setImage:[UIImage imageNamed:@"keyboard_esrth"] forState:UIControlStateNormal];
        }else if (i == 2) {
            [button setImage:[UIImage imageNamed:@"keyboard_ch_en"] forState:UIControlStateNormal];
        }else {
            [button setTitle:superLeftSubs[i] forState:UIControlStateNormal];
        }
    }


    // 右侧view
    CGFloat rightX = self.frame.size.width - spaceX - buttonW;
    //NSArray *superRightSubs = [NSArray arrayWithObjects:@"删除",@"#+=",@"123",@"回车", nil];
    NSArray *superRightSubs = [NSArray arrayWithObjects:@"删除",@",",@"空格",@"回车", nil];
    for (int i=0; i<4; i++) {
        //按钮
        GZFunctionButton *button = [GZFunctionButton buttonWithType:UIButtonTypeCustom];
        //[button setButtonStyleWithSkin:skin];
        [button setBackgroundImage:[UIImage imageNamed:@"key_hightlight"] forState:UIControlStateHighlighted];
        [button setBackgroundColor:[UIColor colorWithHexString:float_Color_button_function alpha:1]];
        [button setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
        button.layer.cornerRadius = 5;

        button.frame = CGRectMake(rightX, top + i*(buttonH+spaceY), buttonW, buttonH);
        [self addSubview:button];

        if (i == 2) {
            //空格
            button.tag = 300;
        }else {
            button.tag = 231+i;
        }

        if (i == 0) {
            [button setImage:[UIImage imageNamed:@"keyboard_clear"] forState:UIControlStateNormal];
            [button addTarget:self action:@selector(didTouchDown) forControlEvents:UIControlEventTouchDown];
            [button addTarget:self action:@selector(didTouchUp) forControlEvents:UIControlEventTouchUpInside];
            [button addTarget:self action:@selector(didTouchUp) forControlEvents:UIControlEventTouchUpOutside]; //移动手指出按钮
        }else {
            if (i == 1) {
                button.titleLabel.font = [UIFont systemFontOfSize:18];
                [button setTitle:superRightSubs[i] forState:UIControlStateNormal];
            }else if (i == 2){
                [button setImage:[UIImage imageNamed:@"keyboard_space_w"] forState:UIControlStateNormal];
                CGSize imageSize = button.imageView.bounds.size;
                button.imageEdgeInsets = UIEdgeInsetsMake(imageSize.height/2.5,0, -imageSize.height/2.5, 0);
            }else {
                [button setImage:[UIImage imageNamed:@"keyboard_enter"] forState:UIControlStateNormal];
            }

            [button addTarget:self action:@selector(didButtonTap:) forControlEvents:UIControlEventTouchUpInside];
        }
    }

    //手写板
    CGSize kbSize = CGSizeMake(self.frame.size.width, self.frame.size.height);
    _strokeView = [[StrokeShowerView alloc] initWithFrame:CGRectMake(0, 0, kbSize.width, kbSize.height) andWrightMode:mode];
    _strokeView.backgroundColor = [UIColor clearColor];
    [self addSubview:_strokeView];
    _strokeView.hidden = YES;
    [superView bringSubviewToFront:_strokeView];
}

//手写模式 1中英文单字符 2中文短句 3中文短句重叠 4自由写
- (void)changeWrightMarkLabel:(int)markMode andHeight:(CGFloat)strokeH{
    NSString *wrightStr = nil;
    if (markMode == 1) {
        wrightStr = @"单字";
    }else if (markMode == 2) {
        wrightStr = @"行写";
    }else if (markMode == 3) {
        wrightStr = @"叠写";
    }else if (markMode == 4) {
        wrightStr = @"自由写";
    }

    CGRect frame_word = CGRectMake(0, strokeH-20, 150, 20);

    UILabel *markLabel = (UILabel*)[self viewWithTag:100];
    if (!markLabel) {
        markLabel = [[UILabel alloc] initWithFrame:frame_word];
        markLabel.textColor = [UIColor lightGrayColor];
        markLabel.textAlignment = NSTextAlignmentLeft;
        markLabel.font = [UIFont systemFontOfSize:15];
        markLabel.tag = 100;
        markLabel.text = wrightStr;
        [_strokePlaceholderView addSubview:markLabel];
    }else {
        markLabel.text = wrightStr;
        markLabel.frame = frame_word;
    }
}



#pragma mark -- button click action
- (void)didButtonTap:(UIButton*)tap {
    UIButton *button = (UIButton*)tap;
    NSInteger tagN = button.tag;
    int text = 0; //1符号，2数字，3中英，4next 5删除 6逗号 7回车 8句号 9空格
    //（211+i） 1符号 2数字 3中英切换 4next  （@"#+=",@"123",@"中英",@"next"）
    // (231+i) 5删除 6逗号  7回车  （@"删除",@",",@"空格",@"回车"）
    //（241）8句号
    //（300）9空格
    switch (tagN) {
        case 211:{
            NSLog(@"符号");
            text = 1;
            break;
        }
        case 212: {
            NSLog(@"数字");
            text = 2;
            break;
        }
        case 213: {
            NSLog(@"中英");
            text = 3;
            break;
        }
        case 214: {
            NSLog(@"next");
            text = 4;
            break;
        }
        case 231: {
            NSLog(@"删除");
            text = 5;
            break;
        }
        case 232: {
            NSLog(@"逗号");
            text = 6;
            break;
        }
        case 234: {
            NSLog(@"回车");
            text = 7;
            break;
        }
        case 241: {
            NSLog(@"句号");
            text = 8;
            break;
        }
        case 300: {
            NSLog(@"空格");
            text = 9;
            break;
        }
        default:
            break;
    }

    if (text != 0 && self.sendSelectedFunc) {
        self.sendSelectedFunc(text);
    }
}

//删除按钮
- (void)didTouchDown {
    NSLog(@"didTouchDown");

    [self deleteActionStart]; //延时问题

    //延时执行 长按删除
    if (!delay) {
        delay = [NSTimer scheduledTimerWithTimeInterval:0.15 target:self selector:@selector(delayAction) userInfo:nil repeats:NO];
    }

}
- (void)didTouchUp {
    NSLog(@"didTouchUp");
    [delay invalidate];
    delay = nil;
    [deleteTimer invalidate];
    deleteTimer = nil;
    [self deleteActionStop];
}

//延时执行 长按删除
- (void)delayAction {
    if (!deleteTimer) {
        deleteTimer = [NSTimer scheduledTimerWithTimeInterval:0.12 target:self selector:@selector(deleteActionStart) userInfo:nil repeats:YES];
    }
}

- (void)deleteActionStart {
    if (self.sendDeleteTap) {
        self.sendDeleteTap(YES);
    }
}
- (void)deleteActionStop {
    if (self.sendDeleteTap) {
        self.sendDeleteTap(NO);
    }
}



#pragma mark - Responding to Touch Events
- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
    UITouch* touch = [touches anyObject];
    if (hiddenStroke) {
        //手写画布隐藏中
        CGPoint point = [touch locationInView:self];
        CGPoint oriPoint = _strokePlaceholderView.frame.origin;
        CGSize oriSize = _strokePlaceholderView.frame.size;
        if (point.x < oriPoint.x || point.x > oriPoint.x+oriSize.width || point.y < oriPoint.y || point.y > oriPoint.y+oriSize.height) {
            return;
        }
    }

    [self dispatchTouches:touches withType:UITouchStart];
    [timer invalidate]; //停止计时
    NSLog(@"start");
}
- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {
    [self dispatchTouches:touches withType:UITouchMove];
    NSLog(@"move");
}
- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
    [self dispatchTouches:touches withType:UITouchUp];
    NSLog(@"up");
}
- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event {
    [_strokeView clearStroke];
    if (self.sendWrightPoint) {
        self.sendWrightPoint(0, CGPointMake(0, 0), 0, 0);
    }
    NSLog(@"cancel");
}

#pragma mark - Private
// 分发触摸事件
- (void)dispatchTouches:(NSSet *)touches withType:(UITouchTypes)type {
    UITouch* touch = [touches anyObject];
    // 手写视图
    [self touchStroke:touch withType:type];
}
// 手写处理
- (BOOL)touchStroke:(UITouch *)touch withType:(UITouchTypes)type {
    if (_strokeView == nil || (touchProcessType != UITouchProcessStroke && type != UITouchStart)) {
        return NO;
    }
    CGPoint point = [touch locationInView:_strokeView];

    switch (type) {
        case UITouchStart:
            if (CGRectContainsPoint(_strokeView.bounds, point)) {
                touchProcessType = UITouchProcessStroke;
                pointInStrokeView = YES;
                [_strokeView strokeStartAtPoint:point];
                if (self.sendWrightPoint) {
                    self.sendWrightPoint(1, point, 0, 0);
                }
            } else {
                return NO;
            }
            break;
        case UITouchMove:
            // 点在视图内
            if (CGRectContainsPoint(_strokeView.bounds, point)) {
                //NSLog(@"视图内");
                if (!pointInStrokeView) {
                    pointInStrokeView = YES;
                    lastStrokePoint = [self correctPoint:lastStrokePoint referenceTo:point withStrokeSize:_strokeView.frame.size];
                    [_strokeView strokeStartAtPoint:lastStrokePoint];

                    if (self.sendWrightPoint) {
                        self.sendWrightPoint(1, lastStrokePoint, 0, 0);
                    }
                }
                [_strokeView strokeMoveToPoint:point];
                if (self.sendWrightPoint) {
                    self.sendWrightPoint(1, point, 0, 0);
                }
            }
            // 点在视图外
            else if (pointInStrokeView) {
                //NSLog(@"视图外");
                pointInStrokeView = NO;
                lastStrokePoint = [self correctPoint:point referenceTo:lastStrokePoint withStrokeSize:_strokeView.frame.size];
                [_strokeView strokeEndAtPoint:lastStrokePoint];
                if (self.sendWrightPoint) {
                    self.sendWrightPoint(2, lastStrokePoint, -1, 0);
                }
            }
            break;
        case UITouchUp: {
            touchProcessType = UITouchProcessUndefined;
            if (!pointInStrokeView) {
                break;
            }
            [_strokeView strokeEndAtPoint:point];
            if (self.sendWrightPoint) {
                self.sendWrightPoint(2, point, -1, 0);
            }
            break;
        }
        default:
            break;

    }

    lastStrokePoint = point;
    return YES;
}



#pragma mark -- private method
// 修正点坐标到手写区域内，获取连接errorPoint和referencePoint的线段上边缘坐标点
// (x-x1)/(x2-x1) = (y-y1)/(y2-y1)
- (CGPoint)correctPoint:(CGPoint)errorPoint referenceTo:(CGPoint)referencePoint withStrokeSize:(CGSize)strokeSize {
    CGFloat threshold = 1;

    // 垂直
    if (ABS(errorPoint.x - referencePoint.x) < threshold) {
        NSLog(@"垂直");
        if(ABS(referencePoint.y - strokeSize.height) > referencePoint.y) {
            return CGPointMake(referencePoint.x, 0);
        } else {
            return CGPointMake(referencePoint.x, strokeSize.height);
        }
    }
    //手写区宽度= 320  高度 ＝ 177
    //    int writeWidth = 320;
    //    int writeHeight = 177;
    int writeWidth = strokeSize.width;
    int writeHeight = strokeSize.height;

    CGFloat calY = 0;
    CGFloat calX = 0;
    if (errorPoint.x < 0) {
        calX = 0;
        calY = referencePoint.x * (referencePoint.y - errorPoint.y ) / (errorPoint.x - referencePoint.x) + referencePoint.y;
        if (calY < 0) {
            calX = referencePoint.y * (referencePoint.x - errorPoint.x ) / (errorPoint.y - referencePoint.y) + referencePoint.x;
            calY = 0;
        }else if (calY > writeHeight){
            calY = writeHeight;
            calX = (referencePoint.y - calY) * (referencePoint.x - errorPoint.x ) / (errorPoint.y - referencePoint.y) + referencePoint.x;

        }

    }else if(errorPoint.x > writeWidth) {
        calX = writeWidth;
        calY = (referencePoint.x - calX) * (referencePoint.y - errorPoint.y ) / (errorPoint.x - referencePoint.x) + referencePoint.y;
        if (calY < 0) {
            calX = referencePoint.y * (referencePoint.x - errorPoint.x ) / (errorPoint.y - referencePoint.y) + referencePoint.x;
            calY = 0;
        }else if (calY > writeHeight){
            calY = writeHeight;
            calX = (referencePoint.y - calY)  * (referencePoint.x - errorPoint.x ) / (errorPoint.y - referencePoint.y) + referencePoint.x;
            calY = writeHeight;
        }
    }else{
        if (errorPoint.y < 0) {
            calY = 0;
            calX = referencePoint.y * (referencePoint.x - errorPoint.x ) / (errorPoint.y - referencePoint.y) + referencePoint.x;
        }else{
            calY = writeHeight;
            calX = (referencePoint.y - calY) * (referencePoint.x - errorPoint.x ) / (errorPoint.y - referencePoint.y) + referencePoint.x;
        }
    }
    return CGPointMake(calX, calY);
}


#pragma mark -- 清除痕迹
- (void)removeTracesAfter {
    timer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(removeTraces) userInfo:nil repeats:NO];
}
- (void)removeTraces {
    [_strokeView clearStroke];
    NSLog(@"手写清除痕迹timer");
}



- (void)dealloc {
    NSLog(@"手写键盘 销毁");
    if (delay) {
        [delay invalidate];
        delay = nil;
    }
    if (timer) {
        [timer invalidate];
        timer = nil;
    }
    if (deleteTimer) {
        [deleteTimer invalidate];
        deleteTimer = nil;
    }


    for (int i=0; i<4; i++) {
        UIButton *but = (UIButton*)[self viewWithTag:211+i];
        if (but) {
            [but removeFromSuperview];
            but = nil;
        }
        UILabel *line = (UILabel*)[self viewWithTag:221+i];
        if (line) {
            [line removeFromSuperview];
            line = nil;
        }
        UIButton *button = (UIButton*)[self viewWithTag:231+i];
        if (button) {
            [button removeFromSuperview];
            button = nil;
        }
    }

    if (_strokeView) {
        [_strokeView removeFromSuperview];
        _strokeView = nil;
    }

    if (_strokePlaceholderView) {
        [_strokePlaceholderView removeFromSuperview];
        _strokePlaceholderView = nil;
    }

    for (UIView *view in self.subviews) {
        [view removeFromSuperview];
    }
}



@end
