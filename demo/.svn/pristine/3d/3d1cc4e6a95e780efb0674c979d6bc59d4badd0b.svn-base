//
//  GZWrightKeyboard.m
//  HanvonKeyboard
//
//  Created by hanvon on 2017/11/4.
//  Copyright © 2017年 hanvon. All rights reserved.
//

#import "GZWrightKeyboard.h"
#import "GZWright.h"
#import "UIStrokeShowerView.h"
//#import "StrokeShowerView.h"


// 触摸类型
typedef enum {
    UITouchStart,
    UITouchMove,
    UITouchUp,
} UITouchTypes;

// 触摸操作类型
typedef enum {
    UITouchProcessUndefined,
    UITouchProcessStroke,
    UITouchProcessKey,
} UITouchProcessType;



@interface GZWrightKeyboard ()
{
@private
    NSInteger touchProcessType;
    BOOL pointInStrokeView;

    CGPoint lastStrokePoint;

    NSTimer *timer;
    NSTimer *deleteTimer;
    //    int timeout;
}
@property (nonatomic,retain) UIStrokeShowerView *strokeView; // 笔迹视图
//@property (nonatomic,strong) UIButton *oneButton;
//@property (nonatomic,strong) UIButton *twoButton;
//@property (nonatomic,strong) UIButton *threeButton;
@end



@implementation GZWrightKeyboard

- (instancetype)initWithFrame:(CGRect)frame {
    self = [super initWithFrame:frame];
    if (self) {
        //创建view
        self.backgroundColor = RGBA(210, 213, 219, 1.0);

        [self createUI:frame];
    }
    return self;
}


- (void)changeViewFrame:(CGRect)newFrame {
    self.frame = newFrame;

    CGFloat spaceX = 5.0;
    CGFloat spaceY = 7.0;
    CGFloat top = 3.0;
    CGFloat bottom = 3.0;

    CGFloat buttonH = (newFrame.size.height - top - bottom - spaceY*3)/4.0; //按钮的高度
    CGFloat buttonW = (newFrame.size.width - spaceX)/8.0; //功能按钮宽度

    //手写板
    CGFloat strokeW = (newFrame.size.width - spaceX - buttonW*2); //手写板宽
    CGFloat strokeH = newFrame.size.height - top - bottom; //手写板高
    CGFloat strokeX = buttonW;

    CGRect rect = CGRectMake(strokeX, top, strokeW, strokeH);
    _strokeView.frame = CGRectIntegral(rect);

    //创建左侧view
    CGFloat leftH = buttonH+spaceY;
    for (int i=0; i<4; i++) {
        //按钮
        GZFunctionButton *button = (GZFunctionButton*)[self viewWithTag:211+i];
        button.frame = CGRectMake(0, i*leftH, buttonW, leftH);

        //分割线
        if (i != 3) {
            UILabel *line = (UILabel*)[self viewWithTag:221+i];
            line.frame = CGRectMake(0, (i+1)*leftH, buttonW, 1);
        }
    }

    // 右侧view
    CGFloat rightX = buttonW + strokeW;
    for (int i=0; i<4; i++) {
        GZFunctionButton *button = (GZFunctionButton*)[self viewWithTag:231+i];
        button.frame = CGRectMake(rightX, top + i*(buttonH+spaceY), buttonW, buttonH);
    }
}


- (void)createUI:(CGRect)newFrame {

    //键盘布局 水平间距5 垂直间距7
    //键盘布局 顶部间距3 底部间距3
    CGFloat spaceX = 5.0;
    CGFloat spaceY = 7.0;
    CGFloat top = 3.0;
    CGFloat bottom = 3.0;

    CGFloat buttonH = (newFrame.size.height - top - bottom - spaceY*3)/4.0; //按钮的高度
    CGFloat buttonW = (newFrame.size.width - spaceX)/8.0; //功能按钮宽度


    //创建手写板
    CGFloat strokeW = (newFrame.size.width - spaceX - buttonW*2); //手写板宽
    CGFloat strokeH = newFrame.size.height - top - bottom; //手写板高
    CGFloat strokeX = buttonW;

    CGRect rect = CGRectMake(strokeX, top, strokeW, strokeH);
    _strokeView = [[UIStrokeShowerView alloc] initWithFrame:CGRectIntegral(rect)];
    _strokeView.backgroundColor = RGBA(210, 213, 219, 1.0);
    [self addSubview:_strokeView];


    //创建左侧view
    CGFloat leftH = buttonH+spaceY;
    NSArray *superLeftSubs = [NSArray arrayWithObjects:@"，",@"空格",@"中英",@"next", nil];
    for (int i=0; i<4; i++) {
        //按钮
        GZFunctionButton *button = [GZFunctionButton buttonWithType:UIButtonTypeSystem];
        button.backgroundColor = [UIColor clearColor];
        [button setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
        button.titleLabel.font = [UIFont systemFontOfSize:18];
        button.layer.shadowColor = [UIColor whiteColor].CGColor;
        button.layer.shadowOpacity = 1.0;
        button.layer.shadowOffset = CGSizeMake(0, 3);
        button.layer.shadowRadius = 5;
        [button addTarget:self action:@selector(didButtonTap:) forControlEvents:UIControlEventTouchUpInside];
        [button setTitle:superLeftSubs[i] forState:UIControlStateNormal];
        [button setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
        button.frame = CGRectMake(0, i*leftH, buttonW, leftH);
        button.tag = 211+i;
        [self addSubview:button];

        //分割线
        if (i != 3) {
            UILabel *line = [[UILabel alloc] initWithFrame:CGRectMake(0, (i+1)*leftH, buttonW, 1)];
            line.backgroundColor = [UIColor whiteColor];
            line.layer.shadowColor = [UIColor whiteColor].CGColor;
            line.layer.shadowOpacity = 1.0;
            line.layer.shadowOffset = CGSizeMake(0, 3);
            line.layer.shadowRadius = 5;
            line.tag = 221+i;
            [self addSubview:line];
        }
    }


    // 右侧view
    CGFloat rightX = buttonW + strokeW;
    NSArray *superRightSubs = [NSArray arrayWithObjects:@"删除",@"符",@"123",@"回车", nil];
    for (int i=0; i<4; i++) {
        //按钮
        GZFunctionButton *button = [GZFunctionButton buttonWithType:UIButtonTypeSystem];
        button.backgroundColor = [UIColor lightGrayColor];
        [button setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
        button.titleLabel.font = [UIFont systemFontOfSize:18];
        button.layer.cornerRadius = 5;
        button.layer.shadowColor = [UIColor whiteColor].CGColor;
        button.layer.shadowOpacity = 1.0;
        button.layer.shadowOffset = CGSizeMake(0, 3);
        button.layer.shadowRadius = 5;
        [button setTitle:superRightSubs[i] forState:UIControlStateNormal];
        [button setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
        button.frame = CGRectMake(rightX, top + i*(buttonH+spaceY), buttonW, buttonH);
        button.tag = 231+i;
        [self addSubview:button];

        if (i == 0) {
            [button addTarget:self action:@selector(didTouchDown) forControlEvents:UIControlEventTouchDown];
            [button addTarget:self action:@selector(didTouchUp) forControlEvents:UIControlEventTouchUpInside];
            [button addTarget:self action:@selector(didTouchUp) forControlEvents:UIControlEventTouchDragInside]; //移动手指出按钮
        }else {
            [button addTarget:self action:@selector(didButtonTap:) forControlEvents:UIControlEventTouchUpInside];
        }
    }

}




#pragma mark -- button click action
- (void)didButtonTap:(UIButton*)tap {
    UIButton *button = (UIButton*)tap;
    NSInteger tagN = button.tag;
    int text = 0; //1逗号，2空格，3中英，4next 5删除 6符号 7数字 8回车
    switch (tagN) {
        case 211:
            text = 1;
            break;
        case 212:
            text = 2;
            break;
        case 213:
            text = 3;
            break;
        case 214:
            text = 4;
            break;
        case 231:
            text = 5;
            break;
        case 232:
            text = 6;
            break;
        case 233:
            text = 7;
            break;
        case 234:
            text = 8;
            break;
        default:
            break;
    }

    if (text != 0 && self.sendSelectedFunc) {
        self.sendSelectedFunc(text);
    }

}


//删除按钮---------------------------------
/*
 UIControlEventTouchDown即按钮按下时应触发的方法。
 实际使用过程中会出现延迟响应或间歇无响应，
 但是放开手指时会直接响应UIControlEventTouchDown、UIControlEventTouchUpInside两个方法
 touchesBegan不响应 不能用之获取按钮坐标
 */
- (void)didTouchDown {
    NSLog(@"didTouchDown");

    [self deleteActionStart]; //延时问题

    if (!deleteTimer) {
        deleteTimer = [NSTimer scheduledTimerWithTimeInterval:0.12 target:self selector:@selector(deleteActionStart) userInfo:nil repeats:YES];
    }
}
- (void)didTouchUp {
    NSLog(@"didTouchUp");
    [deleteTimer invalidate];
    deleteTimer = nil;
    [self deleteActionStop];
}

- (void)deleteActionStart {
    if (self.sendDeleteTap) {
        self.sendDeleteTap(YES);
    }
}
- (void)deleteActionStop {
    if (self.sendDeleteTap) {
        self.sendDeleteTap(NO);
    }
}



#pragma mark - Responding to Touch Events
- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
    [self dispatchTouches:touches withType:UITouchStart];
    [timer invalidate]; //停止计时
}
- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {
    [self dispatchTouches:touches withType:UITouchMove];
}
- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
    [self dispatchTouches:touches withType:UITouchUp];
}
- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event {
    [_strokeView clearStroke];
    if (self.sendWrightPoint) {
        self.sendWrightPoint(0, CGPointMake(0, 0), 0, 0);
    }
}

#pragma mark - Private
// 分发触摸事件
- (void)dispatchTouches:(NSSet *)touches withType:(UITouchTypes)type {
    UITouch* touch = [touches anyObject];
    // 手写视图
    if ([self touchStroke:touch withType:type]) {
        NSLog(@"1111111手写视图");
        return;
    }
    // 按键
    //    if ([self touchKey:touch withType:type]) {
    //        NSLog(@"1111111按键");
    //        return;
    //    }
}
// 手写处理
- (BOOL)touchStroke:(UITouch *)touch withType:(UITouchTypes)type {
    if (_strokeView == nil || (touchProcessType != UITouchProcessStroke && type != UITouchStart)) {
        return NO;
    }
    CGPoint point = [touch locationInView:self];

    point.x -= _strokeView.frame.origin.x;
    point.y -= _strokeView.frame.origin.y;
    switch (type) {
        case UITouchStart:

            if (CGRectContainsPoint(_strokeView.bounds, point)) {
                touchProcessType = UITouchProcessStroke;
                pointInStrokeView = YES;
                [_strokeView strokeStartAtPoint:point];
                if (self.sendWrightPoint) {
                    self.sendWrightPoint(1, point, 0, 0);
                }
            } else {
                return NO;
            }
            break;
        case UITouchMove:
            // 点在视图内

            if (CGRectContainsPoint(_strokeView.bounds, point)) {
                //NSLog(@"视图内");
                if (!pointInStrokeView) {
                    pointInStrokeView = YES;
                    lastStrokePoint = [self correctPoint:lastStrokePoint referenceTo:point withStrokeSize:_strokeView.frame.size];
                    [_strokeView strokeStartAtPoint:lastStrokePoint];

                    if (self.sendWrightPoint) {
                        self.sendWrightPoint(1, lastStrokePoint, 0, 0);
                    }
                }
                [_strokeView strokeMoveToPoint:point];
                if (self.sendWrightPoint) {
                    self.sendWrightPoint(1, point, 0, 0);
                }
            }
            // 点在视图外
            else if (pointInStrokeView) {
                //NSLog(@"视图外");
                pointInStrokeView = NO;
                lastStrokePoint = [self correctPoint:point referenceTo:lastStrokePoint withStrokeSize:_strokeView.frame.size];
                [_strokeView strokeEndAtPoint:lastStrokePoint];
                if (self.sendWrightPoint) {
                    self.sendWrightPoint(2, lastStrokePoint, -1, 0);
                }
            }
            break;
        default:
            touchProcessType = UITouchProcessUndefined;
            if (!pointInStrokeView) {
                break;
            }
            [_strokeView strokeEndAtPoint:point];
            NSLog(@"point .... is  %@",NSStringFromCGPoint(point));
            if (self.sendWrightPoint) {
                self.sendWrightPoint(2, point, -1, 0);
            }
            break;
    }

    lastStrokePoint = point;
    return YES;
}



#pragma mark -- private method
// 修正点坐标到手写区域内，获取连接errorPoint和referencePoint的线段上边缘坐标点
// (x-x1)/(x2-x1) = (y-y1)/(y2-y1)
- (CGPoint)correctPoint:(CGPoint)errorPoint referenceTo:(CGPoint)referencePoint withStrokeSize:(CGSize)strokeSize {
    CGFloat threshold = 1;
    NSLog(@"errorpoint x is %f, y is %f,  referencePoint x is %f, y is %f", errorPoint.x, errorPoint.y, referencePoint.x, referencePoint.y);

    // 垂直
    if (ABS(errorPoint.x - referencePoint.x) < threshold) {
        NSLog(@"垂直");
        if(ABS(referencePoint.y - strokeSize.height) > referencePoint.y) {
            return CGPointMake(referencePoint.x, 0);
        } else {
            return CGPointMake(referencePoint.x, strokeSize.height);
        }
    }
    //手写区宽度= 320  高度 ＝ 177
    //    int writeWidth = 320;
    //    int writeHeight = 177;
    int writeWidth = strokeSize.width;
    int writeHeight = strokeSize.height;

    CGFloat calY = 0;
    CGFloat calX = 0;
    if (errorPoint.x < 0) {
        calX = 0;
        calY = referencePoint.x * (referencePoint.y - errorPoint.y ) / (errorPoint.x - referencePoint.x) + referencePoint.y;
        if (calY < 0) {
            calX = referencePoint.y * (referencePoint.x - errorPoint.x ) / (errorPoint.y - referencePoint.y) + referencePoint.x;
            calY = 0;
        }else if (calY > writeHeight){
            calY = writeHeight;
            calX = (referencePoint.y - calY) * (referencePoint.x - errorPoint.x ) / (errorPoint.y - referencePoint.y) + referencePoint.x;

        }

    }else if(errorPoint.x > writeWidth) {
        calX = writeWidth;
        calY = (referencePoint.x - calX) * (referencePoint.y - errorPoint.y ) / (errorPoint.x - referencePoint.x) + referencePoint.y;
        if (calY < 0) {
            calX = referencePoint.y * (referencePoint.x - errorPoint.x ) / (errorPoint.y - referencePoint.y) + referencePoint.x;
            calY = 0;
        }else if (calY > writeHeight){
            calY = writeHeight;
            calX = (referencePoint.y - calY)  * (referencePoint.x - errorPoint.x ) / (errorPoint.y - referencePoint.y) + referencePoint.x;
            calY = writeHeight;
        }
    }else{
        if (errorPoint.y < 0) {
            calY = 0;
            calX = referencePoint.y * (referencePoint.x - errorPoint.x ) / (errorPoint.y - referencePoint.y) + referencePoint.x;
        }else{
            calY = writeHeight;
            calX = (referencePoint.y - calY) * (referencePoint.x - errorPoint.x ) / (errorPoint.y - referencePoint.y) + referencePoint.x;

            NSLog(@"&&&&&&&&&&&&&&&&&");
        }
    }
    NSLog(@"\n\n\n calX is %f, calY is %f", calX, calY);
    /*

     CGFloat correctX = 0;
     CGFloat correctY = 0;

     // 水平
     if (ABS(errorPoint.y - referencePoint.y) < threshold) {
     NSLog(@"水平");
     return CGPointMake(0, referencePoint.y);
     }


     if (errorPoint.y > referencePoint.y) {
     correctY = 177;
     }

     if (errorPoint.x > referencePoint.x) {
     correctX = 320;
     }

     if (errorPoint.x < 0) {
     NSLog(@"假定与左侧边缘相交");
     // 假定与左侧边缘相交
     correctY = errorPoint.y - (referencePoint.y - errorPoint.y) * errorPoint.x / (referencePoint.x - errorPoint.x);
     // 与上边缘相交
     if (correctY < 0) {
     NSLog(@"与上边缘相交");
     correctY = 0;
     correctX = errorPoint.x - (referencePoint.x - errorPoint.x) * errorPoint.y / (referencePoint.y - errorPoint.y);
     }
     } else {
     NSLog(@"else errorPoint.x < 0");
     correctX = errorPoint.x - (referencePoint.x - errorPoint.x) * errorPoint.y / (referencePoint.y - errorPoint.y);
     }
     */

    return CGPointMake(calX, calY);
}


#pragma mark -- 清除痕迹
- (void)removeTracesAfter {
    timer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(removeTraces) userInfo:nil repeats:NO];
}
- (void)removeTraces {
    [_strokeView clearStroke];
}



- (void)dealloc {
    NSLog(@"手写键盘 销毁");

    if (timer) {
        [timer invalidate];
        timer = nil;
    }
    if (deleteTimer) {
        [deleteTimer invalidate];
        deleteTimer = nil;
    }


    for (int i=0; i<4; i++) {
        UIButton *but = (UIButton*)[self viewWithTag:211+i];
        if (but) {
            [but removeFromSuperview];
            but = nil;
        }
        UILabel *line = (UILabel*)[self viewWithTag:221+i];
        if (line) {
            [line removeFromSuperview];
            line = nil;
        }
        UIButton *button = (UIButton*)[self viewWithTag:231+i];
        if (button) {
            [button removeFromSuperview];
            button = nil;
        }
    }

    if (_strokeView) {
        [_strokeView removeFromSuperview];
        _strokeView = nil;
    }

    for (UIView *view in self.subviews) {
        [view removeFromSuperview];
    }
}



/*
#pragma mark -- abandont
#pragma mark -- UI
- (void)addWrightArea {
    //水平间距5 垂直间距7 顶部间距3 底部间距3
    if (!_strokeView) {
        _strokeView = [[UIStrokeShowerView alloc] initWithFrame:CGRectMake(5, 3, self.frame.size.width-50, self.frame.size.height)];
        _strokeView.backgroundColor = [UIColor whiteColor];
        _strokeView.layer.cornerRadius = 5;
        _strokeView.layer.shadowColor = [UIColor blackColor].CGColor;
        _strokeView.layer.shadowOpacity = 1.0;
        _strokeView.layer.shadowOffset = CGSizeMake(0, 3);
        _strokeView.layer.shadowRadius = 5;
        [self addSubview:_strokeView];
    }
}
- (void)addButton {
    _oneButton = [UIButton buttonWithType:UIButtonTypeSystem];
    [_oneButton setTitle:@"1" forState:UIControlStateNormal];
    _oneButton.layer.cornerRadius = 8;
    _oneButton.backgroundColor = [UIColor whiteColor];
    [_oneButton setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
    _oneButton.titleLabel.font = [UIFont systemFontOfSize:20];
    _oneButton.tag = 101;
    [_oneButton addTarget:self action:@selector(didButtonTap:) forControlEvents:UIControlEventTouchUpInside];
    _oneButton.translatesAutoresizingMaskIntoConstraints = NO;
    [self addSubview:_oneButton];

    _twoButton = [UIButton buttonWithType:UIButtonTypeSystem];
    [_twoButton setTitle:@"2" forState:UIControlStateNormal];
    _twoButton.layer.cornerRadius = 8;
    _twoButton.backgroundColor = [UIColor whiteColor];
    [_twoButton setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
    _twoButton.titleLabel.font = [UIFont systemFontOfSize:20];
    _twoButton.tag = 102;
    [_twoButton addTarget:self action:@selector(didButtonTap:) forControlEvents:UIControlEventTouchUpInside];
    _twoButton.translatesAutoresizingMaskIntoConstraints = NO;
    [self addSubview:_twoButton];

    _threeButton = [UIButton buttonWithType:UIButtonTypeSystem];
    [_threeButton setTitle:@"3" forState:UIControlStateNormal];
    _threeButton.layer.cornerRadius = 8;
    _threeButton.backgroundColor = [UIColor whiteColor];
    [_threeButton setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
    _threeButton.titleLabel.font = [UIFont systemFontOfSize:20];
    _threeButton.tag = 103;
    [_threeButton addTarget:self action:@selector(didButtonTap:) forControlEvents:UIControlEventTouchUpInside];
    _threeButton.translatesAutoresizingMaskIntoConstraints = NO;
    [self addSubview:_threeButton];
}
- (void)addLayout {
    NSDictionary *views = NSDictionaryOfVariableBindings(self,_strokeView,_oneButton,_twoButton,_threeButton);

    [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"H:|[_strokeView]-5-[_oneButton(==_twoButton)]-5-|" options:0 metrics:0 views:views]];
    [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"H:|[_strokeView]-5-[_twoButton(==_threeButton)]-5-|" options:0 metrics:0 views:views]];
    [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"H:|[_strokeView]-5-[_threeButton]-5-|" options:0 metrics:0 views:views]];
    [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"V:|-5-[_oneButton(==_twoButton)]-5-[_twoButton(==_threeButton)]-5-[_threeButton]-5-|" options:0 metrics:0 views:views]];
}
*/



@end
